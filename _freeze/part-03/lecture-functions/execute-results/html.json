{
  "hash": "92c2b9453cfd0ba1f62c6f21b3f1f3fc",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Lecture III - Building Reusable Functions\"\nsubtitle: \"Programming with Python\"\nauthor: \"Dr. Tobias Vlćek\"\ninstitute: \"Kühne Logistics University Hamburg - Fall 2024\"\ntitle-slide-attributes:\n    data-background-color: \"#FFE0D3\"\n\nexecute:\n    echo: true\n\nformat:\n    revealjs:\n        theme: [default, ../styles.scss]\n        transition: slide\n        transition-speed: fast\n        highlight-style: breezedark\n        width: 1260\n        height: 840\n        slide-number: true\n        code-copy: true\n        code-link: true\n        preview-links: auto\n        footer: \" {{< meta title >}} | {{< meta subtitle >}} | {{< meta author >}} | [Home](lecture-functions.qmd)\"\n        output-file: lecture-functions-presentation.html\n    html:\n        theme: litera\n        highlight-style: breezedark\n        linkcolor: \"#a60000\"\n        slide-number: true\n        code-copy: true\n        code-link: true\n        toc: true\n        toc-location: right\n    pdf: \n        documentclass: report\n---\n\n\n# [Quick Recap of the last Lecture]{.flow} {.title}\n\n## Slicing\n\n- With slicing we can get a range of elements from a sequence\n- Syntax: `sequence[start:stop:step]`\n- `start` is the index of the first element to include\n- `stop` is the index of the first element to exclude\n- `step` is the increment between indices\n\n. . .\n\n:::{.callout-tip}\nIf left out, the step defaults to 1. Else, start defaults to 0 and stop defaults to the length of the sequence. Negative indices can be used to slice from the end of the sequence.\n:::\n\n\n## Comparison Operators\n\n- Comparison operators are used to compare two values\n- The result of a comparison is a boolean value (`True` or `False`)\n- Operators include: `==`, `!=`, `>`, `<`, `>=`, `<=`\n\n. . .\n\n[> Question:]{.question} Is this `True`?\n\n::: {#d58deab1 .cell output-location='fragment' execution_count=1}\n``` {.python .cell-code}\n# Careful here!\none = 1\ntwo = 1\nprint(one == two)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTrue\n```\n:::\n:::\n\n\n## Control Structures\n\n- Control structures allow us to control the flow of execution\n- It includes conditional statements and loops\n- Conditional statements: `if`, `elif`, `else`\n- Loops: `for` and `while`\n- Control flow statements (in loops): `continue` and `break`\n\n. . .\n\n:::{.callout-note}\nThe statement `continue` skips the rest of the current iteration and moves to the next one in a loop while the `break` statement exits the loop entirely.\n:::\n\n\n# [Functions in Detail]{.flow} {.title}\n\n## What is a Function?\n- Functions can accept [inputs (parameters)]{.highlight} and [return outputs]{.highlight}\n- Encapsulate logic, making code easier to maintain\n- Functions can be called **multiple times** from different part\n- They help **reduce code duplication** and improve readability\n\n::: {#432fb180 .cell output-location='fragment' execution_count=2}\n``` {.python .cell-code}\n# I'm a function.\ntype(print)\n```\n\n::: {.cell-output .cell-output-display execution_count=18}\n```\nbuiltin_function_or_method\n```\n:::\n:::\n\n\n. . .\n\n::: {.callout-important}\nRemember, methods are [functions]{.highlight} that are called on an [object]{.highlight}.\n:::\n\n## Some Built-in Functions already used\n- `print()`: Print text to console\n- `input()`: Read text from console\n- `len()`: Get the length of a sequence\n- `range()`: Generate a sequence of numbers\n- `round()`: Round a number to a specified number of decimal places\n- `type()`: Get the type of an object\n- `int()`: Convert a string to an integer\n- `float()`: Convert a string to a floating-point number\n- `str()`: Convert an object to a string\n\n## Defining a Function\n- Use the `def` keyword followed by the function name\n- Inside parentheses we list the inputs (parameters)\n- The code block within every function starts with a colon (:)\n- It is [indented]{.highlight}, just as the loops from the last lecture\n\n. . .\n\n::: {#87467ccf .cell output-location='fragment' execution_count=3}\n``` {.python .cell-code}\ndef greet(a_parameter):\n    print(f\"Hello, {a_parameter}!\")\ngreet(\"Students\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHello, Students!\n```\n:::\n:::\n\n\n. . .\n\n:::{.callout-tip}\nIt is common practice to leave out one line after the definition of a function, although we will not always do that in the lecture to save space on the slides.\n:::\n\n## Comment Functions\n\n- It is good practice to include a comment at the top of your functions\n- If you do it with three `\"\"\"`, it will appear in the help menu\n\n. . .\n\n::: {#69cc90e0 .cell output-location='fragment' execution_count=4}\n``` {.python .cell-code}\ndef greet():\n    \"\"\"\n    This function will be used later and has currently\n    absolutely no use for anything.\n    \"\"\"\n    pass # Necessary placeholder to avoid error\n\nhelp(greet)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHelp on function greet in module __main__:\n\ngreet()\n    This function will be used later and has currently\n    absolutely no use for anything.\n\n```\n:::\n:::\n\n\n## Naming Functions (and Methods)\n\n- Function names should be short, but descriptive\n- Use underscores (_) instead of spaces in the names\n- Avoid using Python keywords as function names (e.g., `print`)\n- Try to avoid using built-in functions and methods that have a similar name (e.g., `sum` and `len`)\n\n[> Question:]{.question} Which of the following is a good name for a function? \\\n\n- `myfunctionthatmultipliesvalues`\\ \n- `multiply_two_values`\\\n- `multiplyTwoValues`\n\n## Function Parameters\n- Parameters are variables that the function accepts\n- They allow you to pass data to the function\n- Try to name them as variables: [short and meaningful]{.highlight}\n- We can also **leave them out** or define **several inputs**!\n\n::: {#905b7a07 .cell output-location='fragment' execution_count=5}\n``` {.python .cell-code}\ndef greet():\n    print(\"Hello, stranger!\")\ngreet()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHello, stranger!\n```\n:::\n:::\n\n\n## Function Arguments\n- Arguments are the actual values passed to the function\n- They replace the parameters in the function definition\n\n. . .\n\n[> Question:]{.question} What could be the correct arguments here?\n\n::: {#c3ce0d96 .cell execution_count=6}\n``` {.python .cell-code}\ndef greet(university_name, lecture):\n    print(f\"Hello, students at the {university_name}!\")\n    print(f\"You are in lecture {lecture}!\")\n\n# Your code here\n```\n:::\n\n\n## Initializing Parameters\n- We can also **initialize parameters** to a default value!\n- To do this we use the `=` sign and provide it with a value\n- This is called a [keyword argument]{.highlight}\n\n::: {#362881cd .cell output-location='fragment' execution_count=7}\n``` {.python .cell-code}\ndef greet(lecture=\"Programming with Python\"):\n    print(f\"You are in lecture '{lecture}'!\")\n\ngreet()\ngreet(\"Super Advanced Programming with Python\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nYou are in lecture 'Programming with Python'!\nYou are in lecture 'Super Advanced Programming with Python'!\n```\n:::\n:::\n\n\n. . .\n\n::: {.callout-tip}\nThis is especially useful when we want to avoid errors due to missing arguments!\n:::\n\n## Multiple Parameters\n- We can also have **multiple parameters** in a function definition\n- They are called [positional arguments]{.highlight} and are separated by commas\n- When we call them, they must be provided in the same order\n- Alternatively, we could call them by name, as for example in this function call `print(\"h\",\"i\",sep='')`\n\n. . .\n\n[> Question:]{.question} What will be printed here?\n\n::: {#7a2939a6 .cell output-location='fragment' execution_count=8}\n``` {.python .cell-code}\ndef call_parameters(parameter_a, parameter_b):\n    print(parameter_a, parameter_b)\n\ncall_parameters(parameter_b=\"Hello\", parameter_a=\"World\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nWorld Hello\n```\n:::\n:::\n\n\n## Arbitrary Arguments\n- We can also use **arbitrary arguments** to pass a variable number of arguments to a function\n- This is done by using the `*` sign\n- Python provides two special syntaxes for this\n- `*args` and `**kwargs`.\n\n## *args (Arbitrary Positional Arguments)\n\n- `*args` allows a function to accept any number of positional arguments\n- The arguments are packed into a tuple inside the function\n\n::: {#24dc4f02 .cell output-location='fragment' execution_count=9}\n``` {.python .cell-code}\ndef print_args(*args):\n    for arg in args:\n        print(arg)\n\nprint_args(\"Hello\", \"World\", \"This\", \"is\", \"Python\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHello\nWorld\nThis\nis\nPython\n```\n:::\n:::\n\n\n## **kwargs (Arbitrary Keyword Arguments)\n\n- `**kwargs` allows a function to accept any number of keyword arguments\n- The arguments are packed into a dictionary inside the function\n\n::: {#f963cc6b .cell output-location='fragment' execution_count=10}\n``` {.python .cell-code}\ndef print_kwargs(**kwargs):\n    for key, value in kwargs.items():\n        print(f\"{key}: {value}\")\n\nprint_kwargs(name=\"John\", age=25, city=\"New York\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nname: John\nage: 25\ncity: New York\n```\n:::\n:::\n\n\n## Combining *args and **kwargs\n- We can also combine `*args` and `**kwargs` in a function definition\n- This allows a function to accept any number of positional and keyword arguments\n\n::: {#1c80b384 .cell output-location='fragment' execution_count=11}\n``` {.python .cell-code}\ndef print_args_kwargs(*args, **kwargs):\n    print(\"Positional arguments:\")\n    for arg in args:\n        print(arg)\n    print(\"\\nKeyword arguments:\")\n    for key, value in kwargs.items():\n        print(f\"{key}: {value}\")\n\nprint_args_kwargs(1, 2, 3, name=\"John\", age=25, city=\"New York\")  \n```\n\n::: {.cell-output .cell-output-stdout}\n```\nPositional arguments:\n1\n2\n3\n\nKeyword arguments:\nname: John\nage: 25\ncity: New York\n```\n:::\n:::\n\n\n## Function Return Values\n- Functions can return values using the `return` statement\n- The return statement ends the function \n- It then **returns** the specified value\n\n. . .\n\n::: {#bd5d6fd1 .cell output-location='fragment' execution_count=12}\n``` {.python .cell-code}\ndef simple_multiplication(a,b):\n    result = a*b\n    return result\nprint(simple_multiplication(2,21))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n42\n```\n:::\n:::\n\n\n. . .\n\n::: {#064327a1 .cell output-location='fragment' execution_count=13}\n``` {.python .cell-code}\ndef simple_multiplication(a,b):\n    return a*b # even shorter!\nprint(simple_multiplication(2,21))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n42\n```\n:::\n:::\n\n\n## Access return values\n- We can also **save** the return value from a function in a variable\n- That way we can use it later on in the program\n\n. . .\n\n::: {#2660d481 .cell output-location='fragment' execution_count=14}\n``` {.python .cell-code}\ndef simple_multiplication(a,b):\n    return a*b # even shorter!\n\nresult = simple_multiplication(2,21)\nprint(result)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n42\n```\n:::\n:::\n\n\n## Returning None\n- If we don't specify `return`, functions will return `None`\n\n::: {#84f41907 .cell output-location='fragment' execution_count=15}\n``` {.python .cell-code}\ndef simple_multiplication(a,b):\n    result = a*b\n\nprint(simple_multiplication(2,21))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNone\n```\n:::\n:::\n\n\n. . .\n\n[> Grouptask:]{.task} Come up with a function that checks whether a number is positive or negative. It returns `\"positive\"` for positive numbers and `\"negative\"` for negative numbers.\n\n. . .\n\n::: {.callout-tip}\nYou can also use **multiple return statements** in a function.\n:::\n\n# [Scope]{.flow} {.title}\n\n## Function Scope\n- Variables defined inside a function are local to that function\n- They [cannot]{.highlight} be accessed outside the function\n\n. . .\n\n```python\ndef greet(name):\n    greeting = f\"Hello, {name}!\"\n    \nprint(greeting)  # This will cause an error\n```\n\n. . .\n\n[> Question:]{.question} Any idea how to access `greeting`?\n\n## Global Scope\n- Variables defined **outside** all functions are in the global scope\n- They can be accessed from [anywhere]{.highlight} in the program\n\n. . .\n\n::: {#7353d65e .cell output-location='fragment' execution_count=16}\n``` {.python .cell-code}\ngreeting = \"Hello, Stranger!\"\ndef greet(name):\n   greeting = f\"Hello, {name}!\"\n   return greeting\nprint(greet(\"Students\")) # Greet students\nprint(greeting) # Greet ????\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHello, Students!\nHello, Stranger!\n```\n:::\n:::\n\n\n. . .\n\n:::{.callout-important}\nWe don't change global variables inside a function! The original value can still be accessed from [outside]{.highlight} the function.\n:::\n\n## Global Keyword\n- Still, we can change the value of `greeting` from [inside]{.highlight} a function!\n- By using the `global` keyword to modify a global variable\n\n. . .\n\n::: {#eda21e91 .cell output-location='fragment' execution_count=17}\n``` {.python .cell-code}\ngreeting = \"Hello, Stranger!\"\n\ndef greet(name):\n   global greeting\n   greeting = f\"Hello, {name}!\"\n   return greeting\n\nprint(greet(\"Students\")) # Greet students\nprint(greeting) # Greet students again\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHello, Students!\nHello, Students!\n```\n:::\n:::\n\n\n. . .\n\n[>Question:]{.question} This can be confusing. Do you think you got the idea?\n\n# [Classes]{.flow} {.title}\n\n## Classes\n- Classes are [blueprints]{.highlight} for creating objects\n- They encapsulate data (attributes) and behavior (methods)\n- Objects are instances of classes\n- Methods are functions that are defined within a class\n\n. . .\n\n::: {#de87d3c1 .cell output-location='fragment' execution_count=18}\n``` {.python .cell-code}\nclass Students: # Class definition\n    def know_answer(self): # Method definition\n        print(f\"They know the answer to all questions.\")\n\nstudent = Students() # Object instantiation\nstudent.know_answer()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nThey know the answer to all questions.\n```\n:::\n:::\n\n\n## Self\n- Classes can be [quite tricky at first]{.highlight}, especially the `self` keyword\n- When we call `self` in a method, it refers to the object itself\n- It is used to **access** the attributes and methods of the class\n- `self` always needs to be included in method definitions\n\n. . .\n\n::: {#f01797d2 .cell execution_count=19}\n``` {.python .cell-code}\n# This won't work as self is missing\nclass Students: # Class definition\n    def know_answer(): # Method definition without self\n        print(f\"They know the answer to all questions.\")\n\nstudent = Students()\nstudent.know_answer()\n```\n:::\n\n\n. . .\n\n[>Task:]{.task} Try it yourself, what is the error?\n\n## Naming Classes\n- Classes can be named anything, but it is common to use the plural form of their name (e.g., `People`)\n- CamelCase is used for class names, and snake_case is used for method and attribute names (e.g., `TallPeople`)\n- Classes are usually defined in a file with the same name as their class, but with a `.py` extension\n\n. . .\n\n[Question:]{.question} Which of the following is a good class name? `smart_student`, `SmartStudent`, or `SmartStudents`\n\n## Class Attributes\n- Class attributes are attributes that are shared by all class instances\n- They are defined **within** the class but **outside** any methods\n\n. . .\n\n[>Question:]{.question} What do you think will happen here?\n\n::: {#6dd939ed .cell output-location='fragment' execution_count=20}\n``` {.python .cell-code}\nclass Students: # Class definition\n    smart = True # Class attribute\n\nstudent_A = Students() # Object instantiation student_A\nstudent_B = Students() # Object instantiation student_B\n\nprint(student_A.smart)\nprint(student_B.smart)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTrue\nTrue\n```\n:::\n:::\n\n\n## Instance Attributes\n- Instance attributes are attributes unique to each class instance\n- They are defined within the `__init__` method\n\n::: {#a86e123a .cell output-location='fragment' execution_count=21}\n``` {.python .cell-code}\nclass Student: # Class definition\n    def __init__(self, name, is_smart): # Method for initalization\n        self.name = name\n        self.smart = is_smart\n    def knows_answer(self): # Method to be called\n        if self.smart:\n            print(f\"{self.name} knows the answer to the question.\")\n        else:\n            print(f\"{self.name} does not know the answer to the question.\")\n\nstudent = Student(\"Buddy\",False) # Note, we don't need to call self here!\nstudent.knows_answer()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nBuddy does not know the answer to the question.\n```\n:::\n:::\n\n\n## Inheritance\n- Inheritance allows a class to [inherit attributes and methods]{.highlight} \n- The class that inherits is called the **subclass**\n- The class that is being inherited from is called the **superclass**\n\n. . .\n\n:::{.callout-tip}\nDon't worry! \\ It can be quite much right now. Hang in there and soon it will get easier again!\n:::\n\n\n## Inheritance in Action\n\n::: {#be27cf99 .cell execution_count=22}\n``` {.python .cell-code}\nclass Student: # Superclass\n    def __init__(self, name):\n        self.name = name\n    def when_asked(self):\n        pass\n\nclass SmartStudent(Student): # Subclass\n    def when_asked(self):\n        return f\"{self.name} knows the answer!\"\n        \nclass LazyStudent(Student): # Subclass\n    def when_asked(self):\n        return f\"{self.name} has to ask ChatGPT!\"\n```\n:::\n\n\n[>Grouptask:]{.task} Create two students. One is smart and the other one is lazy. Make sure that both students reaction to a question is printed.\n\n## Encapsulation\n- Encapsulation is the concept of bundling data (attributes) and methods (behavior) that operate on the data into a single unit (class)\n- It is a key aspect of object oriented programming (OOP)\n- It helps in organizing code and controlling access\n\n. . .\n\n:::{.callout-note}\nFortunately, this is an introduction to Python, so we won't go into details of encapsulation.\n:::\n\n## The End\n\n- Interested in more detail about classes and OOP?\n- Check out [access modifiers, getters and setters]{.highlight}\n- They are definitely a bit more complicated for beginners...\n- Though they are worth learning if you build **complex programs**\n\n. . .\n\n::: {.callout-note}\n**And that's it for todays lecture!**\\\nWe now have covered the basics of funtions and classes. We will continue with some slightly easier topics in the next lectures.\n:::\n\n[Literature]{.flow} {.title}\n\n## Interesting Book to dive deeper\n\n- Thomas, D., & Hunt, A. (2019). The pragmatic programmer, 20th anniversary edition: Journey to mastery (Second edition). Addison-Wesley.\n\n. . .\n\n::: {.callout-tip}\nA fantastic textbook to understand the principles of modern software development and how to create effective software. Also available as a really good audiobook!\n:::\n\n. . .\n\nFor more interesting literature to learn more about Python, take a look at the [literature list](../general/literature.qmd) of this course.\n\n",
    "supporting": [
      "lecture-functions_files"
    ],
    "filters": [],
    "includes": {}
  }
}