[
  {
    "objectID": "part-02/lecture-presentation.html#f-strings",
    "href": "part-02/lecture-presentation.html#f-strings",
    "title": "Lecture II - Control Structures for Your Code",
    "section": "F-Strings",
    "text": "F-Strings\n\nF-strings provide a way to embed expressions inside string literals\nYou can include expressions by placing them inside curly braces {}\nThis makes it easier to include dynamic content\n\n\n\n# Let's illustrate f-strings with a small example:\nname = \"Mr. Smith\"\nage = 30\nheight = 1.826549\nprint(f\"My name is {name}, I'm {age} years old, and {height:.2f} meters tall.\")\n\n\n\nMy name is Mr. Smith, I'm 30 years old, and 1.83 meters tall.\n\n\n\n\n\n\n\n\n\n\nTip\n\n\nWe used the :.2f format specifier to round the number to two decimal places (new)."
  },
  {
    "objectID": "part-02/lecture-presentation.html#variables-and-data-types",
    "href": "part-02/lecture-presentation.html#variables-and-data-types",
    "title": "Lecture II - Control Structures for Your Code",
    "section": "Variables and Data Types",
    "text": "Variables and Data Types\n\nPython uses dynamic typing, i.e. the type is determined at runtime\nBasic data types in Python are: int, float, str, bool\nVariables are created by assignment with the = operator\n\n\n&gt; Question: What are the types of y, z, w?\n\ny = 2.5\nz = \"Hello\"\nw = True\nprint(f\"y is of type {type(y).__name__}\")\nprint(f\"z is of type {type(z).__name__}\")\nprint(f\"w is of type {type(w).__name__}\")\n\n\n\ny is of type float\nz is of type str\nw is of type bool"
  },
  {
    "objectID": "part-02/lecture-presentation.html#arithmetic-operators",
    "href": "part-02/lecture-presentation.html#arithmetic-operators",
    "title": "Lecture II - Control Structures for Your Code",
    "section": "Arithmetic Operators",
    "text": "Arithmetic Operators\n\n\nAddition\nSubtraction\nMultiplication\nDivision\nFloor Division\nExponentiation\nModulo\n\n+\n-\n*\n/\n//\n**\n%\n\nAdds two numbers\nSubtracts one number from another\nMultiplies two numbers\nFloating-point division\nInteger division\nPower of\nRemainder of division\n\n\n\n\n\n\n\n\nNote\n\n\nNote, that the / operator always returns a float, even if the division is even. Furthermore, the + operator can be used to concatenate strings and that the * operator can be used to repeat strings."
  },
  {
    "objectID": "part-02/lecture-presentation.html#arithmetic-operators-with-variables",
    "href": "part-02/lecture-presentation.html#arithmetic-operators-with-variables",
    "title": "Lecture II - Control Structures for Your Code",
    "section": "Arithmetic Operators with Variables",
    "text": "Arithmetic Operators with Variables\n\nAdditional operators can update the value of a variable (new)\nWe can use +=, -=, *=, /=, //=, **=, %=\n\n\n&gt; Question: What is the value of x after the operations?\n\nx = 10\nprint(f\"Initial value of x: {x}\")\nx += 5  # Equivalent to x = x + 5\nprint(f\"After x += 5: {x}\")\nx *= 2  # Equivalent to x = x * 2\nprint(f\"After x *= 2: {x}\")\nx %= 4  # Equivalent to x = x % 4\nprint(f\"After x %= 4: {x}\")\n\n\n\nInitial value of x: 10\nAfter x += 5: 15\nAfter x *= 2: 30\nAfter x %= 4: 2"
  },
  {
    "objectID": "part-02/lecture-presentation.html#objects",
    "href": "part-02/lecture-presentation.html#objects",
    "title": "Lecture II - Control Structures for Your Code",
    "section": "Objects",
    "text": "Objects\n\nObjects are instances of classes\nWe will learn more about classes later in the course\nIn Python, virtually everything is an object\nCommon built-in objects: integers, strings, lists, dictionaries\nFor now, think of objects as a collection of data and methods\n\n\n\n\n\n\n\n\nNote\n\n\nFor most programming purposes, you can treat everything in Python as an object. This means you can assign all types to variables, pass them to functions, and in many cases, call methods on them."
  },
  {
    "objectID": "part-02/lecture-presentation.html#methods",
    "href": "part-02/lecture-presentation.html#methods",
    "title": "Lecture II - Control Structures for Your Code",
    "section": "Methods",
    "text": "Methods\n\nMethods are functions that are called on an object\nThe syntax is object.method([arguments])\nMethods are specific to the type of object they’re called on\nThey can modify the object or return information about it\n\n\n\n\n\n\n\n\nTip\n\n\nYou can use the dir() function to list all methods and attributes of an object."
  },
  {
    "objectID": "part-02/lecture-presentation.html#string-methods",
    "href": "part-02/lecture-presentation.html#string-methods",
    "title": "Lecture II - Control Structures for Your Code",
    "section": "String Methods",
    "text": "String Methods\nHere are some commonly used string methods:\n\nupper(): Converts all characters in the string to uppercase\nlower(): Converts all characters in the string to lowercase\ntitle(): Converts first character of each word to uppercase\nstrip(): Removes leading and trailing whitespace\nreplace(): Replaces a substring with another substring\nfind(): Finds first substring and returns its index\ncount(): Counts the number of occurrences of a substring"
  },
  {
    "objectID": "part-02/lecture-presentation.html#string-methods-in-action",
    "href": "part-02/lecture-presentation.html#string-methods-in-action",
    "title": "Lecture II - Control Structures for Your Code",
    "section": "String Methods in Action",
    "text": "String Methods in Action\n&gt; Question: What will be the output of the following code?\n\nmessage = \"Hello, World!\"\nprint(message.upper())  # Converts to uppercase\nprint(message.lower())  # Converts to lowercase\nprint(message.title())  # Converts to title case\nprint(message.replace(\"World\", \"Python\"))  # Replaces \"World\" with \"Python\"\nprint(message.find(\"World\"))  # Finds \"World\" and returns its index\nprint(message.count(\"o\"))  # Counts the number of occurrences of \"o\"\n\n\n\nHELLO, WORLD!\nhello, world!\nHello, World!\nHello, Python!\n7\n2\n\n\n\n\n\n\n\n\n\nNote\n\n\nNote, how replace() does not modify the original string. Instead, it returns a new string."
  },
  {
    "objectID": "part-02/lecture-presentation.html#string-task",
    "href": "part-02/lecture-presentation.html#string-task",
    "title": "Lecture II - Control Structures for Your Code",
    "section": "String Task",
    "text": "String Task\n&gt; Grouptask: Discuss and implement the following task:\n\n# Change the following message to get the desired output\nmessage = \" the snake programmer. \"\n# Your code here\n\noutput = \"The Python Programmer.\"\n\n\n\n\n\n\n\n\nTip\n\n\nRemember, that these methods return a new string. The original string is not modified."
  },
  {
    "objectID": "part-02/lecture-presentation.html#indexing",
    "href": "part-02/lecture-presentation.html#indexing",
    "title": "Lecture II - Control Structures for Your Code",
    "section": "Indexing",
    "text": "Indexing\n\nWe have used indexing to access elements of a string last lecture\nIt allows you to access elements of a sequence by position\nPositive indexing starts at 0 for the first element\nNegative indexing starts at -1 for the last element (new)\n\n\n\nstring_to_index = \"Hello, World!\"\nprint(string_to_index[0])  # Accessing the first character\nprint(string_to_index[-1]) # Accessing the last character\n\n\n\nH\n!"
  },
  {
    "objectID": "part-02/lecture-presentation.html#slicing",
    "href": "part-02/lecture-presentation.html#slicing",
    "title": "Lecture II - Control Structures for Your Code",
    "section": "Slicing",
    "text": "Slicing\n\nSlicing allows you to extract a portion of a sequence\nSyntax: sequence[start:stop:step]\nstart is the index of the first element to include\nstop is the index of the first element to exclude\nstep is the increment between indices (default is 1)\nThe result is a new sequence containing the extracted elements\n\n\n\nstring_to_slice = \"Hello, World!\"\nprint(string_to_slice[7:12])   # Accessing the last five characters from the start\nprint(string_to_slice[-6:-1])  # Accessing the last five characters from the end\n\n\n\nWorld\nWorld"
  },
  {
    "objectID": "part-02/lecture-presentation.html#slicing-simplified",
    "href": "part-02/lecture-presentation.html#slicing-simplified",
    "title": "Lecture II - Control Structures for Your Code",
    "section": "Slicing Simplified",
    "text": "Slicing Simplified\n\nIf we omit start or stop, it will be replaced by the start or end of the sequence, respectively\nIf we omit step, it will be replaced by 1\n\n\n\nstring_to_slice = \"Hello, World!\"\nprint(string_to_slice[::2])   # Accessing every second character\nprint(string_to_slice[::-1])  # Accessing the string in reverse\n\n\n\nHlo ol!\n!dlroW ,olleH"
  },
  {
    "objectID": "part-02/lecture-presentation.html#slicing-string-task",
    "href": "part-02/lecture-presentation.html#slicing-string-task",
    "title": "Lecture II - Control Structures for Your Code",
    "section": "Slicing String Task",
    "text": "Slicing String Task\n&gt; Grouptask: Discuss and implement the following task:\n\n# Slice the following message to create the described output\nmessage = \"y6S0-teru89d23e'.n*ut\"\n# Your code here\n\noutput = \"Student\"\n\n\n\n\n\n\n\n\nTip\n\n\nRemember, that these methods return a new string. The original string is not modified."
  },
  {
    "objectID": "part-02/lecture-presentation.html#comparison-operators",
    "href": "part-02/lecture-presentation.html#comparison-operators",
    "title": "Lecture II - Control Structures for Your Code",
    "section": "Comparison Operators",
    "text": "Comparison Operators\n\nComparison operators are used to compare two values\nThe result of a comparison is a boolean value (True or False)\n\n\n&gt; Question: What will be the output of the following code?\n\nlower_number = 2; upper_number = 9\nprint(lower_number == upper_number) # Equality\nprint(lower_number != upper_number) # Inequality\nprint(lower_number &gt; upper_number) # Greater than\nprint(lower_number &lt; upper_number) # Less than\nprint(lower_number &gt;= upper_number) # Greater than or equal to\nprint(lower_number &lt;= upper_number) # Less than or equal to \n\n\n\nFalse\nTrue\nFalse\nTrue\nFalse\nTrue"
  },
  {
    "objectID": "part-02/lecture-presentation.html#logical-operators",
    "href": "part-02/lecture-presentation.html#logical-operators",
    "title": "Lecture II - Control Structures for Your Code",
    "section": "Logical Operators",
    "text": "Logical Operators\n\nLogical operators combine multiple comparison operators\nCommon logical operators: and, or, not\n\n\n&gt; Question: Which of the following expressions is True?\n\nlower_number = 2; middle_number = 5; upper_number = 9; \nprint(lower_number &lt; middle_number and middle_number &lt; upper_number) # and\nprint(lower_number &lt; middle_number or middle_number &gt; upper_number) # or\nprint(lower_number == lower_number and not lower_number &gt; middle_number) # not\n\n\n\nTrue\nTrue\nTrue\n\n\n\n\n\n\n\n\n\n\nNote\n\n\nNote, that and and or are evaluated from left to right."
  },
  {
    "objectID": "part-02/lecture-presentation.html#membership-operators",
    "href": "part-02/lecture-presentation.html#membership-operators",
    "title": "Lecture II - Control Structures for Your Code",
    "section": "Membership Operators",
    "text": "Membership Operators\n\nUsed to check if a value is present in a sequence\nCommon membership operators: in, not in\n\n\n&gt; Question: Which of these expressions is True?\n\nan_apple = \"apple\"\nprint(\"a\" in an_apple) # Check if \"a\" is in the string \"apple\"\nprint(\"pp\" not in an_apple) # Check if \"pp\" is not in the string\n\n\n\nTrue\nFalse\n\n\n\n\n\n\n\n\n\n\nNote\n\n\nNote, that in and not in can be used for strings, lists, tuples, sets, and dictionaries. Don’t worry! We will learn about lists, tuples, sets, and dictionaries later in the course."
  },
  {
    "objectID": "part-02/lecture-presentation.html#control-structures-1",
    "href": "part-02/lecture-presentation.html#control-structures-1",
    "title": "Lecture II - Control Structures for Your Code",
    "section": "Control Structures",
    "text": "Control Structures\n\nUsed to control the flow of execution in a program\nThey can be used to make decisions and repeat code blocks\nif, elif, else, for, while, break, continue\n\n\n&gt; Question: What do you think each of the above does?"
  },
  {
    "objectID": "part-02/lecture-presentation.html#indentation",
    "href": "part-02/lecture-presentation.html#indentation",
    "title": "Lecture II - Control Structures for Your Code",
    "section": "Indentation",
    "text": "Indentation\n\nIndentation is crucial in Python!\nIt is used to indicate the block of code that belongs to the structure\nThe standard indentation is 4 spaces\nYou can use tabs, but you should be careful with that\n\n\n\n\n\n\n\n\nWarning\n\n\nMixing tabs and spaces can cause errors that are difficult to debug. The Python style guide (PEP 8) recommends using 4 spaces per indentation level for consistency and readability."
  },
  {
    "objectID": "part-02/lecture-presentation.html#conditional-statements-1",
    "href": "part-02/lecture-presentation.html#conditional-statements-1",
    "title": "Lecture II - Control Structures for Your Code",
    "section": "Conditional Statements",
    "text": "Conditional Statements\n\nThey are used to execute different blocks of code based on whether a condition is true or false:\n\nif statements execute a block of code if a condition is True\nelif statements execute a block of code if the previous condition is False and the current condition is True\nelse statements execute a block of code if the previous conditions are False\n\n\n\n\n\n\n\n\n\nTip\n\n\nYou can use the and and or operators to combine multiple conditions."
  },
  {
    "objectID": "part-02/lecture-presentation.html#if-statements",
    "href": "part-02/lecture-presentation.html#if-statements",
    "title": "Lecture II - Control Structures for Your Code",
    "section": "if-statements",
    "text": "if-statements\n\ncondition = True\nif condition:\n    print(\"The condition is True!\") # Code block to execute if condition is True\nprint(\"This will always be printed!\")\n\n\n\nThe condition is True!\nThis will always be printed!\n\n\n\n\ncondition = False\nif condition:\n    print(\"The condition is True!\") # Code block to execute if condition is True\nprint(\"This will always be printed!\")\n\n\n\nThis will always be printed!\n\n\n\n\n\n\n\n\n\n\nTip\n\n\nWriting if condition: is equivalent to if condition == True:"
  },
  {
    "objectID": "part-02/lecture-presentation.html#else-statements",
    "href": "part-02/lecture-presentation.html#else-statements",
    "title": "Lecture II - Control Structures for Your Code",
    "section": "else-statements",
    "text": "else-statements\n\ncondition = True\nif condition:\n    print(\"The condition is True!\") # Code block to execute if condition is True\nelse:\n    print(\"The condition is False!\") # Code block to execute if condition is False\n\n\n\nThe condition is True!\n\n\n\n\ncondition = False\nif condition:\n    print(\"The condition is True!\") # Code block to execute if condition is True\nelse:\n    print(\"The condition is False!\") # Code block to execute if condition is False\n\n\n\nThe condition is False!"
  },
  {
    "objectID": "part-02/lecture-presentation.html#elif-statements",
    "href": "part-02/lecture-presentation.html#elif-statements",
    "title": "Lecture II - Control Structures for Your Code",
    "section": "elif-statements",
    "text": "elif-statements\n\ntemperature = 11\nif temperature &gt; 10:\n    print(\"The temperature is greater than 10!\")\nelif temperature == 10:\n    print(\"The temperature is equal to 10!\")\nelse:\n    print(\"The temperature is less than 10!\")\n\n\n\nThe temperature is greater than 10!\n\n\n\n\ntemperature = 10\nif temperature &gt; 10:\n    print(\"The temperature is greater than 10!\")\nelif temperature == 10:\n    print(\"The temperature is equal to 10!\")\nelse:\n    print(\"The temperature is less than 10!\")\n\n\n\nThe temperature is equal to 10!"
  },
  {
    "objectID": "part-02/lecture-presentation.html#comparisons-and-conditional-statements",
    "href": "part-02/lecture-presentation.html#comparisons-and-conditional-statements",
    "title": "Lecture II - Control Structures for Your Code",
    "section": "Comparisons and Conditional Statements",
    "text": "Comparisons and Conditional Statements\n&gt; Question: What will be the output of the following code?\n\nname = \"Harry\"\nprofession = \"wizard\"\nage = 16\nif name == \"Harry\" and profession == \"wizard\" and age &lt; 18:\n    print(\"You are the chosen one still visiting school!\")\nelif name == \"Harry\" and profession == \"wizard\" and age &gt;= 18:\n    print(\"You are the chosen one and can start your journey!\")\nelse:\n    print(\"You are not the chosen one!\")\n\n\n\nYou are the chosen one still visiting school!"
  },
  {
    "objectID": "part-02/lecture-presentation.html#loops-1",
    "href": "part-02/lecture-presentation.html#loops-1",
    "title": "Lecture II - Control Structures for Your Code",
    "section": "Loops",
    "text": "Loops\n\nLoops allow you to execute a block of code repeatedly\nThere are two types of loops: for and while\nfor loops are used to iterate over a sequence (e.g., list, tuple, string)\nwhile loops execute repeatedly until a condition is False\n\n\n\n\n\n\n\n\nTip\n\n\nNested control structures through further indentation are allowed as well, we thus can chain multiple control structures together."
  },
  {
    "objectID": "part-02/lecture-presentation.html#for-loops",
    "href": "part-02/lecture-presentation.html#for-loops",
    "title": "Lecture II - Control Structures for Your Code",
    "section": "for-loops",
    "text": "for-loops\n\nfor i in range(5):\n    print(i)\n\n\n\n0\n1\n2\n3\n4\n\n\n\nfor i in range(0, 10, 2):\n    print(i)\n\n\n\n0\n2\n4\n6\n8\n\n\n\n\n\n\n\n\n\nTip\n\n\nThe range() function can take up to three arguments: start, stop, and step."
  },
  {
    "objectID": "part-02/lecture-presentation.html#for-loops-with-lists",
    "href": "part-02/lecture-presentation.html#for-loops-with-lists",
    "title": "Lecture II - Control Structures for Your Code",
    "section": "for-loops with lists",
    "text": "for-loops with lists\n&gt; Question: What do you expect will be the output?\n\nfruit = \"yellow banana\"\nfor letter in fruit:\n    print(letter)\n\n\n\ny\ne\nl\nl\no\nw\n \nb\na\nn\na\nn\na"
  },
  {
    "objectID": "part-02/lecture-presentation.html#while-loops",
    "href": "part-02/lecture-presentation.html#while-loops",
    "title": "Lecture II - Control Structures for Your Code",
    "section": "while-loops",
    "text": "while-loops\n\ni = 0\nwhile i &lt; 5:\n    print(i)\n    i += 1\n\n\n\n0\n1\n2\n3\n4\n\n\n\n&gt; Question: What could be an issue with poorly written while-loops?"
  },
  {
    "objectID": "part-02/lecture-presentation.html#while-true",
    "href": "part-02/lecture-presentation.html#while-true",
    "title": "Lecture II - Control Structures for Your Code",
    "section": "while True",
    "text": "while True\n&gt; Question: Anybody an idea what this code does?\n\ni = 0\nwhile True:\n    if i % 10 == 0:\n         print(i)\n    if i &gt; 100:\n        break\n    i += 1\n\n\n\n0\n10\n20\n30\n40\n50\n60\n70\n80\n90\n100"
  },
  {
    "objectID": "part-02/lecture-presentation.html#importance-of-control-flow",
    "href": "part-02/lecture-presentation.html#importance-of-control-flow",
    "title": "Lecture II - Control Structures for Your Code",
    "section": "Importance of Control Flow",
    "text": "Importance of Control Flow\n\nAllows programs to make decisions based on conditions\nEnables repetition of code blocks\nHelps manage program complexity\nImproves efficiency by executing only necessary code\nFacilitates creation of dynamic, responsive programs\n\n\n\n\n\n\n\n\nNote\n\n\nWithout control flow, programs would execute linearly from top to bottom, limiting their functionality and flexibility."
  },
  {
    "objectID": "part-02/lecture-presentation.html#loop-task",
    "href": "part-02/lecture-presentation.html#loop-task",
    "title": "Lecture II - Control Structures for Your Code",
    "section": "Loop Task",
    "text": "Loop Task\n&gt; Grouptask: Implement the following task:\n\n# Implement a while-loop that prints all even numbers between 0 and 100\nnumber = 0\n# Your code here\n\n\n\n\n\n\n\n\nNote\n\n\nAnd that’s it for todays lecture!\nWe now have covered the basics on String methods, Comparisons, conditional statements and loops.\n\n\n\nLiterature {.title}"
  },
  {
    "objectID": "part-02/lecture-presentation.html#interesting-books-to-start",
    "href": "part-02/lecture-presentation.html#interesting-books-to-start",
    "title": "Lecture II - Control Structures for Your Code",
    "section": "Interesting Books to start",
    "text": "Interesting Books to start\n\nDowney, A. B. (2024). Think Python: How to think like a computer scientist (Third edition). O’Reilly. Link to free online version\nElter, S. (2021). Schrödinger programmiert Python: Das etwas andere Fachbuch (1. Auflage). Rheinwerk Verlag.\n\n\n\n\n\n\n\n\nTip\n\n\nNothing new here, but these are stillgreat books to start with!\n\n\n\n\n\nFor more interesting literature to learn more about Python, take a look at the literature list of this course.\n\n\n\nLecture II - Control Structures for Your Code | Programming with Python | Dr. Tobias Vlćek | Home"
  },
  {
    "objectID": "part-02/lecture-control.html",
    "href": "part-02/lecture-control.html",
    "title": "Lecture II - Control Structures for Your Code",
    "section": "",
    "text": "F-strings provide a way to embed expressions inside string literals\nYou can include expressions by placing them inside curly braces {}\nThis makes it easier to include dynamic content\n\n. . .\n\n# Let's illustrate f-strings with a small example:\nname = \"Mr. Smith\"\nage = 30\nheight = 1.826549\nprint(f\"My name is {name}, I'm {age} years old, and {height:.2f} meters tall.\")\n\nMy name is Mr. Smith, I'm 30 years old, and 1.83 meters tall.\n\n\n. . .\n\n\n\n\n\n\nTip\n\n\n\nWe used the :.2f format specifier to round the number to two decimal places (new).\n\n\n\n\n\n\nPython uses dynamic typing, i.e. the type is determined at runtime\nBasic data types in Python are: int, float, str, bool\nVariables are created by assignment with the = operator\n\n. . .\n&gt; Question: What are the types of y, z, w?\n\ny = 2.5\nz = \"Hello\"\nw = True\nprint(f\"y is of type {type(y).__name__}\")\nprint(f\"z is of type {type(z).__name__}\")\nprint(f\"w is of type {type(w).__name__}\")\n\ny is of type float\nz is of type str\nw is of type bool\n\n\n\n\n\n\n\nAddition\nSubtraction\nMultiplication\nDivision\nFloor Division\nExponentiation\nModulo\n\n+\n-\n*\n/\n//\n**\n%\n\nAdds two numbers\nSubtracts one number from another\nMultiplies two numbers\nFloating-point division\nInteger division\nPower of\nRemainder of division\n\n\n. . .\n\n\n\n\n\n\nNote\n\n\n\nNote, that the / operator always returns a float, even if the division is even. Furthermore, the + operator can be used to concatenate strings and that the * operator can be used to repeat strings.\n\n\n\n\n\n\nAdditional operators can update the value of a variable (new)\nWe can use +=, -=, *=, /=, //=, **=, %=\n\n. . .\n&gt; Question: What is the value of x after the operations?\n\nx = 10\nprint(f\"Initial value of x: {x}\")\nx += 5  # Equivalent to x = x + 5\nprint(f\"After x += 5: {x}\")\nx *= 2  # Equivalent to x = x * 2\nprint(f\"After x *= 2: {x}\")\nx %= 4  # Equivalent to x = x % 4\nprint(f\"After x %= 4: {x}\")\n\nInitial value of x: 10\nAfter x += 5: 15\nAfter x *= 2: 30\nAfter x %= 4: 2",
    "crumbs": [
      "02 Control",
      "Lecture"
    ]
  },
  {
    "objectID": "part-02/lecture-control.html#f-strings",
    "href": "part-02/lecture-control.html#f-strings",
    "title": "Lecture II - Control Structures for Your Code",
    "section": "",
    "text": "F-strings provide a way to embed expressions inside string literals\nYou can include expressions by placing them inside curly braces {}\nThis makes it easier to include dynamic content\n\n. . .\n\n# Let's illustrate f-strings with a small example:\nname = \"Mr. Smith\"\nage = 30\nheight = 1.826549\nprint(f\"My name is {name}, I'm {age} years old, and {height:.2f} meters tall.\")\n\nMy name is Mr. Smith, I'm 30 years old, and 1.83 meters tall.\n\n\n. . .\n\n\n\n\n\n\nTip\n\n\n\nWe used the :.2f format specifier to round the number to two decimal places (new).",
    "crumbs": [
      "02 Control",
      "Lecture"
    ]
  },
  {
    "objectID": "part-02/lecture-control.html#variables-and-data-types",
    "href": "part-02/lecture-control.html#variables-and-data-types",
    "title": "Lecture II - Control Structures for Your Code",
    "section": "",
    "text": "Python uses dynamic typing, i.e. the type is determined at runtime\nBasic data types in Python are: int, float, str, bool\nVariables are created by assignment with the = operator\n\n. . .\n&gt; Question: What are the types of y, z, w?\n\ny = 2.5\nz = \"Hello\"\nw = True\nprint(f\"y is of type {type(y).__name__}\")\nprint(f\"z is of type {type(z).__name__}\")\nprint(f\"w is of type {type(w).__name__}\")\n\ny is of type float\nz is of type str\nw is of type bool",
    "crumbs": [
      "02 Control",
      "Lecture"
    ]
  },
  {
    "objectID": "part-02/lecture-control.html#arithmetic-operators",
    "href": "part-02/lecture-control.html#arithmetic-operators",
    "title": "Lecture II - Control Structures for Your Code",
    "section": "",
    "text": "Addition\nSubtraction\nMultiplication\nDivision\nFloor Division\nExponentiation\nModulo\n\n+\n-\n*\n/\n//\n**\n%\n\nAdds two numbers\nSubtracts one number from another\nMultiplies two numbers\nFloating-point division\nInteger division\nPower of\nRemainder of division\n\n\n. . .\n\n\n\n\n\n\nNote\n\n\n\nNote, that the / operator always returns a float, even if the division is even. Furthermore, the + operator can be used to concatenate strings and that the * operator can be used to repeat strings.",
    "crumbs": [
      "02 Control",
      "Lecture"
    ]
  },
  {
    "objectID": "part-02/lecture-control.html#arithmetic-operators-with-variables",
    "href": "part-02/lecture-control.html#arithmetic-operators-with-variables",
    "title": "Lecture II - Control Structures for Your Code",
    "section": "",
    "text": "Additional operators can update the value of a variable (new)\nWe can use +=, -=, *=, /=, //=, **=, %=\n\n. . .\n&gt; Question: What is the value of x after the operations?\n\nx = 10\nprint(f\"Initial value of x: {x}\")\nx += 5  # Equivalent to x = x + 5\nprint(f\"After x += 5: {x}\")\nx *= 2  # Equivalent to x = x * 2\nprint(f\"After x *= 2: {x}\")\nx %= 4  # Equivalent to x = x % 4\nprint(f\"After x %= 4: {x}\")\n\nInitial value of x: 10\nAfter x += 5: 15\nAfter x *= 2: 30\nAfter x %= 4: 2",
    "crumbs": [
      "02 Control",
      "Lecture"
    ]
  },
  {
    "objectID": "part-02/lecture-control.html#objects",
    "href": "part-02/lecture-control.html#objects",
    "title": "Lecture II - Control Structures for Your Code",
    "section": "Objects",
    "text": "Objects\n\nObjects are instances of classes\nWe will learn more about classes later in the course\nIn Python, virtually everything is an object\nCommon built-in objects: integers, strings, lists, dictionaries\nFor now, think of objects as a collection of data and methods\n\n. . .\n\n\n\n\n\n\nNote\n\n\n\nFor most programming purposes, you can treat everything in Python as an object. This means you can assign all types to variables, pass them to functions, and in many cases, call methods on them.",
    "crumbs": [
      "02 Control",
      "Lecture"
    ]
  },
  {
    "objectID": "part-02/lecture-control.html#methods",
    "href": "part-02/lecture-control.html#methods",
    "title": "Lecture II - Control Structures for Your Code",
    "section": "Methods",
    "text": "Methods\n\nMethods are functions that are called on an object\nThe syntax is object.method([arguments])\nMethods are specific to the type of object they’re called on\nThey can modify the object or return information about it\n\n. . .\n\n\n\n\n\n\nTip\n\n\n\nYou can use the dir() function to list all methods and attributes of an object.",
    "crumbs": [
      "02 Control",
      "Lecture"
    ]
  },
  {
    "objectID": "part-02/lecture-control.html#string-methods",
    "href": "part-02/lecture-control.html#string-methods",
    "title": "Lecture II - Control Structures for Your Code",
    "section": "String Methods",
    "text": "String Methods\nHere are some commonly used string methods:\n\nupper(): Converts all characters in the string to uppercase\nlower(): Converts all characters in the string to lowercase\ntitle(): Converts first character of each word to uppercase\nstrip(): Removes leading and trailing whitespace\nreplace(): Replaces a substring with another substring\nfind(): Finds first substring and returns its index\ncount(): Counts the number of occurrences of a substring",
    "crumbs": [
      "02 Control",
      "Lecture"
    ]
  },
  {
    "objectID": "part-02/lecture-control.html#string-methods-in-action",
    "href": "part-02/lecture-control.html#string-methods-in-action",
    "title": "Lecture II - Control Structures for Your Code",
    "section": "String Methods in Action",
    "text": "String Methods in Action\n&gt; Question: What will be the output of the following code?\n\nmessage = \"Hello, World!\"\nprint(message.upper())  # Converts to uppercase\nprint(message.lower())  # Converts to lowercase\nprint(message.title())  # Converts to title case\nprint(message.replace(\"World\", \"Python\"))  # Replaces \"World\" with \"Python\"\nprint(message.find(\"World\"))  # Finds \"World\" and returns its index\nprint(message.count(\"o\"))  # Counts the number of occurrences of \"o\"\n\nHELLO, WORLD!\nhello, world!\nHello, World!\nHello, Python!\n7\n2\n\n\n. . .\n\n\n\n\n\n\nNote\n\n\n\nNote, how replace() does not modify the original string. Instead, it returns a new string.",
    "crumbs": [
      "02 Control",
      "Lecture"
    ]
  },
  {
    "objectID": "part-02/lecture-control.html#string-task",
    "href": "part-02/lecture-control.html#string-task",
    "title": "Lecture II - Control Structures for Your Code",
    "section": "String Task",
    "text": "String Task\n&gt; Grouptask: Discuss and implement the following task:\n\n# Change the following message to get the desired output\nmessage = \" the snake programmer. \"\n# Your code here\n\noutput = \"The Python Programmer.\"\n\n. . .\n\n\n\n\n\n\nTip\n\n\n\nRemember, that these methods return a new string. The original string is not modified.",
    "crumbs": [
      "02 Control",
      "Lecture"
    ]
  },
  {
    "objectID": "part-02/lecture-control.html#indexing",
    "href": "part-02/lecture-control.html#indexing",
    "title": "Lecture II - Control Structures for Your Code",
    "section": "Indexing",
    "text": "Indexing\n\nWe have used indexing to access elements of a string last lecture\nIt allows you to access elements of a sequence by position\nPositive indexing starts at 0 for the first element\nNegative indexing starts at -1 for the last element (new)\n\n. . .\n\nstring_to_index = \"Hello, World!\"\nprint(string_to_index[0])  # Accessing the first character\nprint(string_to_index[-1]) # Accessing the last character\n\nH\n!",
    "crumbs": [
      "02 Control",
      "Lecture"
    ]
  },
  {
    "objectID": "part-02/lecture-control.html#slicing",
    "href": "part-02/lecture-control.html#slicing",
    "title": "Lecture II - Control Structures for Your Code",
    "section": "Slicing",
    "text": "Slicing\n\nSlicing allows you to extract a portion of a sequence\nSyntax: sequence[start:stop:step]\nstart is the index of the first element to include\nstop is the index of the first element to exclude\nstep is the increment between indices (default is 1)\nThe result is a new sequence containing the extracted elements\n\n. . .\n\nstring_to_slice = \"Hello, World!\"\nprint(string_to_slice[7:12])   # Accessing the last five characters from the start\nprint(string_to_slice[-6:-1])  # Accessing the last five characters from the end\n\nWorld\nWorld",
    "crumbs": [
      "02 Control",
      "Lecture"
    ]
  },
  {
    "objectID": "part-02/lecture-control.html#slicing-simplified",
    "href": "part-02/lecture-control.html#slicing-simplified",
    "title": "Lecture II - Control Structures for Your Code",
    "section": "Slicing Simplified",
    "text": "Slicing Simplified\n\nIf we omit start or stop, it will be replaced by the start or end of the sequence, respectively\nIf we omit step, it will be replaced by 1\n\n. . .\n\nstring_to_slice = \"Hello, World!\"\nprint(string_to_slice[::2])   # Accessing every second character\nprint(string_to_slice[::-1])  # Accessing the string in reverse\n\nHlo ol!\n!dlroW ,olleH",
    "crumbs": [
      "02 Control",
      "Lecture"
    ]
  },
  {
    "objectID": "part-02/lecture-control.html#slicing-string-task",
    "href": "part-02/lecture-control.html#slicing-string-task",
    "title": "Lecture II - Control Structures for Your Code",
    "section": "Slicing String Task",
    "text": "Slicing String Task\n&gt; Grouptask: Discuss and implement the following task:\n\n# Slice the following message to create the described output\nmessage = \"y6S0-teru89d23e'.n*ut\"\n# Your code here\n\noutput = \"Student\"\n\n. . .\n\n\n\n\n\n\nTip\n\n\n\nRemember, that these methods return a new string. The original string is not modified.",
    "crumbs": [
      "02 Control",
      "Lecture"
    ]
  },
  {
    "objectID": "part-02/lecture-control.html#comparison-operators",
    "href": "part-02/lecture-control.html#comparison-operators",
    "title": "Lecture II - Control Structures for Your Code",
    "section": "Comparison Operators",
    "text": "Comparison Operators\n\nComparison operators are used to compare two values\nThe result of a comparison is a boolean value (True or False)\n\n. . .\n&gt; Question: What will be the output of the following code?\n\nlower_number = 2; upper_number = 9\nprint(lower_number == upper_number) # Equality\nprint(lower_number != upper_number) # Inequality\nprint(lower_number &gt; upper_number) # Greater than\nprint(lower_number &lt; upper_number) # Less than\nprint(lower_number &gt;= upper_number) # Greater than or equal to\nprint(lower_number &lt;= upper_number) # Less than or equal to \n\nFalse\nTrue\nFalse\nTrue\nFalse\nTrue",
    "crumbs": [
      "02 Control",
      "Lecture"
    ]
  },
  {
    "objectID": "part-02/lecture-control.html#logical-operators",
    "href": "part-02/lecture-control.html#logical-operators",
    "title": "Lecture II - Control Structures for Your Code",
    "section": "Logical Operators",
    "text": "Logical Operators\n\nLogical operators combine multiple comparison operators\nCommon logical operators: and, or, not\n\n. . .\n&gt; Question: Which of the following expressions is True?\n\nlower_number = 2; middle_number = 5; upper_number = 9; \nprint(lower_number &lt; middle_number and middle_number &lt; upper_number) # and\nprint(lower_number &lt; middle_number or middle_number &gt; upper_number) # or\nprint(lower_number == lower_number and not lower_number &gt; middle_number) # not\n\nTrue\nTrue\nTrue\n\n\n. . .\n\n\n\n\n\n\nNote\n\n\n\nNote, that and and or are evaluated from left to right.",
    "crumbs": [
      "02 Control",
      "Lecture"
    ]
  },
  {
    "objectID": "part-02/lecture-control.html#membership-operators",
    "href": "part-02/lecture-control.html#membership-operators",
    "title": "Lecture II - Control Structures for Your Code",
    "section": "Membership Operators",
    "text": "Membership Operators\n\nUsed to check if a value is present in a sequence\nCommon membership operators: in, not in\n\n. . .\n&gt; Question: Which of these expressions is True?\n\nan_apple = \"apple\"\nprint(\"a\" in an_apple) # Check if \"a\" is in the string \"apple\"\nprint(\"pp\" not in an_apple) # Check if \"pp\" is not in the string\n\nTrue\nFalse\n\n\n. . .\n\n\n\n\n\n\nNote\n\n\n\nNote, that in and not in can be used for strings, lists, tuples, sets, and dictionaries. Don’t worry! We will learn about lists, tuples, sets, and dictionaries later in the course.",
    "crumbs": [
      "02 Control",
      "Lecture"
    ]
  },
  {
    "objectID": "part-02/lecture-control.html#control-structures-1",
    "href": "part-02/lecture-control.html#control-structures-1",
    "title": "Lecture II - Control Structures for Your Code",
    "section": "Control Structures",
    "text": "Control Structures\n\nUsed to control the flow of execution in a program\nThey can be used to make decisions and repeat code blocks\nif, elif, else, for, while, break, continue\n\n. . .\n&gt; Question: What do you think each of the above does?",
    "crumbs": [
      "02 Control",
      "Lecture"
    ]
  },
  {
    "objectID": "part-02/lecture-control.html#indentation",
    "href": "part-02/lecture-control.html#indentation",
    "title": "Lecture II - Control Structures for Your Code",
    "section": "Indentation",
    "text": "Indentation\n\nIndentation is crucial in Python!\nIt is used to indicate the block of code that belongs to the structure\nThe standard indentation is 4 spaces\nYou can use tabs, but you should be careful with that\n\n. . .\n\n\n\n\n\n\nWarning\n\n\n\nMixing tabs and spaces can cause errors that are difficult to debug. The Python style guide (PEP 8) recommends using 4 spaces per indentation level for consistency and readability.",
    "crumbs": [
      "02 Control",
      "Lecture"
    ]
  },
  {
    "objectID": "part-02/lecture-control.html#conditional-statements-1",
    "href": "part-02/lecture-control.html#conditional-statements-1",
    "title": "Lecture II - Control Structures for Your Code",
    "section": "Conditional Statements",
    "text": "Conditional Statements\n\nThey are used to execute different blocks of code based on whether a condition is true or false:\n\nif statements execute a block of code if a condition is True\nelif statements execute a block of code if the previous condition is False and the current condition is True\nelse statements execute a block of code if the previous conditions are False\n\n\n. . .\n\n\n\n\n\n\nTip\n\n\n\nYou can use the and and or operators to combine multiple conditions.",
    "crumbs": [
      "02 Control",
      "Lecture"
    ]
  },
  {
    "objectID": "part-02/lecture-control.html#if-statements",
    "href": "part-02/lecture-control.html#if-statements",
    "title": "Lecture II - Control Structures for Your Code",
    "section": "if-statements",
    "text": "if-statements\n\ncondition = True\nif condition:\n    print(\"The condition is True!\") # Code block to execute if condition is True\nprint(\"This will always be printed!\")\n\nThe condition is True!\nThis will always be printed!\n\n\n. . .\n\ncondition = False\nif condition:\n    print(\"The condition is True!\") # Code block to execute if condition is True\nprint(\"This will always be printed!\")\n\nThis will always be printed!\n\n\n. . .\n\n\n\n\n\n\nTip\n\n\n\nWriting if condition: is equivalent to if condition == True:",
    "crumbs": [
      "02 Control",
      "Lecture"
    ]
  },
  {
    "objectID": "part-02/lecture-control.html#else-statements",
    "href": "part-02/lecture-control.html#else-statements",
    "title": "Lecture II - Control Structures for Your Code",
    "section": "else-statements",
    "text": "else-statements\n\ncondition = True\nif condition:\n    print(\"The condition is True!\") # Code block to execute if condition is True\nelse:\n    print(\"The condition is False!\") # Code block to execute if condition is False\n\nThe condition is True!\n\n\n. . .\n\ncondition = False\nif condition:\n    print(\"The condition is True!\") # Code block to execute if condition is True\nelse:\n    print(\"The condition is False!\") # Code block to execute if condition is False\n\nThe condition is False!",
    "crumbs": [
      "02 Control",
      "Lecture"
    ]
  },
  {
    "objectID": "part-02/lecture-control.html#elif-statements",
    "href": "part-02/lecture-control.html#elif-statements",
    "title": "Lecture II - Control Structures for Your Code",
    "section": "elif-statements",
    "text": "elif-statements\n\ntemperature = 11\nif temperature &gt; 10:\n    print(\"The temperature is greater than 10!\")\nelif temperature == 10:\n    print(\"The temperature is equal to 10!\")\nelse:\n    print(\"The temperature is less than 10!\")\n\nThe temperature is greater than 10!\n\n\n. . .\n\ntemperature = 10\nif temperature &gt; 10:\n    print(\"The temperature is greater than 10!\")\nelif temperature == 10:\n    print(\"The temperature is equal to 10!\")\nelse:\n    print(\"The temperature is less than 10!\")\n\nThe temperature is equal to 10!",
    "crumbs": [
      "02 Control",
      "Lecture"
    ]
  },
  {
    "objectID": "part-02/lecture-control.html#comparisons-and-conditional-statements",
    "href": "part-02/lecture-control.html#comparisons-and-conditional-statements",
    "title": "Lecture II - Control Structures for Your Code",
    "section": "Comparisons and Conditional Statements",
    "text": "Comparisons and Conditional Statements\n&gt; Question: What will be the output of the following code?\n\nname = \"Harry\"\nprofession = \"wizard\"\nage = 16\nif name == \"Harry\" and profession == \"wizard\" and age &lt; 18:\n    print(\"You are the chosen one still visiting school!\")\nelif name == \"Harry\" and profession == \"wizard\" and age &gt;= 18:\n    print(\"You are the chosen one and can start your journey!\")\nelse:\n    print(\"You are not the chosen one!\")\n\nYou are the chosen one still visiting school!",
    "crumbs": [
      "02 Control",
      "Lecture"
    ]
  },
  {
    "objectID": "part-02/lecture-control.html#loops-1",
    "href": "part-02/lecture-control.html#loops-1",
    "title": "Lecture II - Control Structures for Your Code",
    "section": "Loops",
    "text": "Loops\n\nLoops allow you to execute a block of code repeatedly\nThere are two types of loops: for and while\nfor loops are used to iterate over a sequence (e.g., list, tuple, string)\nwhile loops execute repeatedly until a condition is False\n\n. . .\n\n\n\n\n\n\nTip\n\n\n\nNested control structures through further indentation are allowed as well, we thus can chain multiple control structures together.",
    "crumbs": [
      "02 Control",
      "Lecture"
    ]
  },
  {
    "objectID": "part-02/lecture-control.html#for-loops",
    "href": "part-02/lecture-control.html#for-loops",
    "title": "Lecture II - Control Structures for Your Code",
    "section": "for-loops",
    "text": "for-loops\n\nfor i in range(5):\n    print(i)\n\n0\n1\n2\n3\n4\n\n\n\nfor i in range(0, 10, 2):\n    print(i)\n\n0\n2\n4\n6\n8\n\n\n. . .\n\n\n\n\n\n\nTip\n\n\n\nThe range() function can take up to three arguments: start, stop, and step.\n\n\n. . .",
    "crumbs": [
      "02 Control",
      "Lecture"
    ]
  },
  {
    "objectID": "part-02/lecture-control.html#for-loops-with-lists",
    "href": "part-02/lecture-control.html#for-loops-with-lists",
    "title": "Lecture II - Control Structures for Your Code",
    "section": "for-loops with lists",
    "text": "for-loops with lists\n&gt; Question: What do you expect will be the output?\n\nfruit = \"yellow banana\"\nfor letter in fruit:\n    print(letter)\n\ny\ne\nl\nl\no\nw\n \nb\na\nn\na\nn\na",
    "crumbs": [
      "02 Control",
      "Lecture"
    ]
  },
  {
    "objectID": "part-02/lecture-control.html#while-loops",
    "href": "part-02/lecture-control.html#while-loops",
    "title": "Lecture II - Control Structures for Your Code",
    "section": "while-loops",
    "text": "while-loops\n\ni = 0\nwhile i &lt; 5:\n    print(i)\n    i += 1\n\n0\n1\n2\n3\n4\n\n\n. . .\n&gt; Question: What could be an issue with poorly written while-loops?",
    "crumbs": [
      "02 Control",
      "Lecture"
    ]
  },
  {
    "objectID": "part-02/lecture-control.html#while-true",
    "href": "part-02/lecture-control.html#while-true",
    "title": "Lecture II - Control Structures for Your Code",
    "section": "while True",
    "text": "while True\n&gt; Question: Anybody an idea what this code does?\n\ni = 0\nwhile True:\n    if i % 10 == 0:\n         print(i)\n    if i &gt; 100:\n        break\n    i += 1\n\n0\n10\n20\n30\n40\n50\n60\n70\n80\n90\n100",
    "crumbs": [
      "02 Control",
      "Lecture"
    ]
  },
  {
    "objectID": "part-02/lecture-control.html#importance-of-control-flow",
    "href": "part-02/lecture-control.html#importance-of-control-flow",
    "title": "Lecture II - Control Structures for Your Code",
    "section": "Importance of Control Flow",
    "text": "Importance of Control Flow\n\nAllows programs to make decisions based on conditions\nEnables repetition of code blocks\nHelps manage program complexity\nImproves efficiency by executing only necessary code\nFacilitates creation of dynamic, responsive programs\n\n. . .\n\n\n\n\n\n\nNote\n\n\n\nWithout control flow, programs would execute linearly from top to bottom, limiting their functionality and flexibility.",
    "crumbs": [
      "02 Control",
      "Lecture"
    ]
  },
  {
    "objectID": "part-02/lecture-control.html#loop-task",
    "href": "part-02/lecture-control.html#loop-task",
    "title": "Lecture II - Control Structures for Your Code",
    "section": "Loop Task",
    "text": "Loop Task\n&gt; Grouptask: Implement the following task:\n\n# Implement a while-loop that prints all even numbers between 0 and 100\nnumber = 0\n# Your code here\n\n. . .\n\n\n\n\n\n\nNote\n\n\n\nAnd that’s it for todays lecture!\nWe now have covered the basics on String methods, Comparisons, conditional statements and loops.\n\n\nLiterature {.title}",
    "crumbs": [
      "02 Control",
      "Lecture"
    ]
  },
  {
    "objectID": "part-02/lecture-control.html#interesting-books-to-start",
    "href": "part-02/lecture-control.html#interesting-books-to-start",
    "title": "Lecture II - Control Structures for Your Code",
    "section": "Interesting Books to start",
    "text": "Interesting Books to start\n\nDowney, A. B. (2024). Think Python: How to think like a computer scientist (Third edition). O’Reilly. Link to free online version\nElter, S. (2021). Schrödinger programmiert Python: Das etwas andere Fachbuch (1. Auflage). Rheinwerk Verlag.\n\n. . .\n\n\n\n\n\n\nTip\n\n\n\nNothing new here, but these are still great books to start with!\n\n\n. . .\nFor more interesting literature to learn more about Python, take a look at the literature list of this course.",
    "crumbs": [
      "02 Control",
      "Lecture"
    ]
  },
  {
    "objectID": "part-03/lecture-presentation.html#what-is-a-function",
    "href": "part-03/lecture-presentation.html#what-is-a-function",
    "title": "Lecture III - Building Reusable Functions",
    "section": "What is a Function?",
    "text": "What is a Function?\n\nFunctions can accept inputs (parameters) and return outputs\nEncapsulate logic, making code easier to maintain\nFunctions can be called multiple times from different part\nThey help reduce code duplication and improve readability"
  },
  {
    "objectID": "part-03/lecture-presentation.html#functions-you-have-already-used",
    "href": "part-03/lecture-presentation.html#functions-you-have-already-used",
    "title": "Lecture III - Building Reusable Functions",
    "section": "Functions you have already used",
    "text": "Functions you have already used\n\nprint()\ninput()\nlen()\nrange()\nround()\ntype()\nint()\nfloat()\nstr()"
  },
  {
    "objectID": "part-03/lecture-presentation.html#defining-a-function",
    "href": "part-03/lecture-presentation.html#defining-a-function",
    "title": "Lecture III - Building Reusable Functions",
    "section": "Defining a Function",
    "text": "Defining a Function\n\nUse the def keyword followed by the function name and parentheses\nThe code block within every function starts with a colon (:) and is indented\n\ndef greet(name):\n    print(f\"Hello, {name}!\")\n\ngreet(\"Alice\")  # Output: Hello, Alice!"
  },
  {
    "objectID": "part-03/lecture-presentation.html#function-parameters",
    "href": "part-03/lecture-presentation.html#function-parameters",
    "title": "Lecture III - Building Reusable Functions",
    "section": "Function Parameters",
    "text": "Function Parameters\n\nParameters are variables that the function accepts\nThey allow you to pass data to the function"
  },
  {
    "objectID": "part-03/lecture-presentation.html#example",
    "href": "part-03/lecture-presentation.html#example",
    "title": "Lecture III - Building Reusable Functions",
    "section": "Example",
    "text": "Example\ndef greet(name):\n    print(f\"Hello, {name}!\")"
  },
  {
    "objectID": "part-03/lecture-presentation.html#function-arguments",
    "href": "part-03/lecture-presentation.html#function-arguments",
    "title": "Lecture III - Building Reusable Functions",
    "section": "Function Arguments",
    "text": "Function Arguments\n\nArguments are the actual values passed to the function\nThey replace the parameters in the function definition"
  },
  {
    "objectID": "part-03/lecture-presentation.html#example-1",
    "href": "part-03/lecture-presentation.html#example-1",
    "title": "Lecture III - Building Reusable Functions",
    "section": "Example",
    "text": "Example\ndef greet(name):\n    print(f\"Hello, {name}!\")"
  },
  {
    "objectID": "part-03/lecture-presentation.html#function-return-values",
    "href": "part-03/lecture-presentation.html#function-return-values",
    "title": "Lecture III - Building Reusable Functions",
    "section": "Function Return Values",
    "text": "Function Return Values\n\nFunctions can return values using the return statement\nThe return statement ends the function and returns the specified value"
  },
  {
    "objectID": "part-03/lecture-presentation.html#example-2",
    "href": "part-03/lecture-presentation.html#example-2",
    "title": "Lecture III - Building Reusable Functions",
    "section": "Example",
    "text": "Example\ndef add(a, b):\n    return a + b"
  },
  {
    "objectID": "part-03/lecture-presentation.html#function-scope",
    "href": "part-03/lecture-presentation.html#function-scope",
    "title": "Lecture III - Building Reusable Functions",
    "section": "Function Scope",
    "text": "Function Scope\n\nVariables defined inside a function are local to that function\nThey cannot be accessed outside the function\n\ndef greet(name):\n    greeting = f\"Hello, {name}!\"\n    \nprint(greeting)  # This will cause an error"
  },
  {
    "objectID": "part-03/lecture-presentation.html#global-scope",
    "href": "part-03/lecture-presentation.html#global-scope",
    "title": "Lecture III - Building Reusable Functions",
    "section": "Global Scope",
    "text": "Global Scope\n\nVariables defined outside all functions are in the global scope\nThey can be accessed from anywhere in the program"
  },
  {
    "objectID": "part-03/lecture-presentation.html#example-3",
    "href": "part-03/lecture-presentation.html#example-3",
    "title": "Lecture III - Building Reusable Functions",
    "section": "Example",
    "text": "Example\nname = \"Alice\"\n\ndef greet():\n    print(f\"Hello, {name}!\")\n\ngreet()  # Output: Hello, Alice!"
  },
  {
    "objectID": "part-03/lecture-presentation.html#local-scope",
    "href": "part-03/lecture-presentation.html#local-scope",
    "title": "Lecture III - Building Reusable Functions",
    "section": "Local Scope",
    "text": "Local Scope\n\nVariables defined inside a function are in the local scope\nThey can only be accessed within that function"
  },
  {
    "objectID": "part-03/lecture-presentation.html#example-4",
    "href": "part-03/lecture-presentation.html#example-4",
    "title": "Lecture III - Building Reusable Functions",
    "section": "Example",
    "text": "Example\ndef greet(name):\n    greeting = f\"Hello, {name}!\"\n    \nprint(greeting)  # This will cause an error"
  },
  {
    "objectID": "part-03/lecture-presentation.html#global-keyword",
    "href": "part-03/lecture-presentation.html#global-keyword",
    "title": "Lecture III - Building Reusable Functions",
    "section": "Global Keyword",
    "text": "Global Keyword\n\nUse the global keyword to modify a global variable inside a function"
  },
  {
    "objectID": "part-03/lecture-presentation.html#example-5",
    "href": "part-03/lecture-presentation.html#example-5",
    "title": "Lecture III - Building Reusable Functions",
    "section": "Example",
    "text": "Example\ndef modify_global():\n    global name\n    name = \"Bob\"\n\nmodify_global()\nprint(name)  # Output: Bob"
  },
  {
    "objectID": "part-03/lecture-presentation.html#built-in-functions",
    "href": "part-03/lecture-presentation.html#built-in-functions",
    "title": "Lecture III - Building Reusable Functions",
    "section": "Built-in Functions",
    "text": "Built-in Functions\n\nPython has many built-in functions that are always available\nExamples include print(), len(), range(), max(), min(), etc."
  },
  {
    "objectID": "part-03/lecture-presentation.html#example-6",
    "href": "part-03/lecture-presentation.html#example-6",
    "title": "Lecture III - Building Reusable Functions",
    "section": "Example",
    "text": "Example\nprint(\"Hello, World!\")  # Output: Hello, World!"
  },
  {
    "objectID": "part-03/lecture-presentation.html#classes-1",
    "href": "part-03/lecture-presentation.html#classes-1",
    "title": "Lecture III - Building Reusable Functions",
    "section": "Classes",
    "text": "Classes\n\nClasses are blueprints for creating objects\nThey encapsulate data (attributes) and behavior (methods)\nObjects are instances of classes"
  },
  {
    "objectID": "part-03/lecture-presentation.html#example-7",
    "href": "part-03/lecture-presentation.html#example-7",
    "title": "Lecture III - Building Reusable Functions",
    "section": "Example",
    "text": "Example\nclass Dog:\n    def __init__(self, name):\n        self.name = name\n\n    def bark(self):\n        print(f\"{self.name} says woof!\")\n\ndog = Dog(\"Buddy\")\ndog.bark()  # Output: Buddy says woof!"
  },
  {
    "objectID": "part-03/lecture-presentation.html#class-attributes",
    "href": "part-03/lecture-presentation.html#class-attributes",
    "title": "Lecture III - Building Reusable Functions",
    "section": "Class Attributes",
    "text": "Class Attributes\n\nClass attributes are attributes that are shared by all instances of a class\nThey are defined within the class but outside any methods"
  },
  {
    "objectID": "part-03/lecture-presentation.html#example-8",
    "href": "part-03/lecture-presentation.html#example-8",
    "title": "Lecture III - Building Reusable Functions",
    "section": "Example",
    "text": "Example\nclass Dog:\n    species = \"Canis familiaris\"\n\ndog1 = Dog()\ndog2 = Dog()\n\nprint(dog1.species)  # Output: Canis familiaris\nprint(dog2.species)  # Output: Canis familiaris"
  },
  {
    "objectID": "part-03/lecture-presentation.html#instance-attributes",
    "href": "part-03/lecture-presentation.html#instance-attributes",
    "title": "Lecture III - Building Reusable Functions",
    "section": "Instance Attributes",
    "text": "Instance Attributes\n\nInstance attributes are attributes that are unique to each instance of a class\nThey are defined within the __init__ method"
  },
  {
    "objectID": "part-03/lecture-presentation.html#example-9",
    "href": "part-03/lecture-presentation.html#example-9",
    "title": "Lecture III - Building Reusable Functions",
    "section": "Example",
    "text": "Example\nclass Dog:\n    def __init__(self, name):\n        self.name = name\n\ndog1 = Dog(\"Buddy\")\ndog2 = Dog(\"Max\")\n\nprint(dog1.name)  # Output: Buddy\nprint(dog2.name)  # Output: Max"
  },
  {
    "objectID": "part-03/lecture-presentation.html#methods",
    "href": "part-03/lecture-presentation.html#methods",
    "title": "Lecture III - Building Reusable Functions",
    "section": "Methods",
    "text": "Methods\n\nMethods are functions that are defined within a class\nThey operate on the instance attributes of the class"
  },
  {
    "objectID": "part-03/lecture-presentation.html#example-10",
    "href": "part-03/lecture-presentation.html#example-10",
    "title": "Lecture III - Building Reusable Functions",
    "section": "Example",
    "text": "Example\nclass Dog:\n    def __init__(self, name):\n        self.name = name\n\n    def bark(self):\n        print(f\"{self.name} says woof!\")\n\ndog = Dog(\"Buddy\")\ndog.bark()  # Output: Buddy says woof!"
  },
  {
    "objectID": "part-03/lecture-presentation.html#inheritance",
    "href": "part-03/lecture-presentation.html#inheritance",
    "title": "Lecture III - Building Reusable Functions",
    "section": "Inheritance",
    "text": "Inheritance\n\nInheritance allows a class to inherit attributes and methods from another class\nThe class that inherits is called the subclass, and the class being inherited from is the superclass"
  },
  {
    "objectID": "part-03/lecture-presentation.html#example-11",
    "href": "part-03/lecture-presentation.html#example-11",
    "title": "Lecture III - Building Reusable Functions",
    "section": "Example",
    "text": "Example\nclass Animal:\n    def __init__(self, name):\n        self.name = name\n\n    def speak(self):\n        pass\n\nclass Dog(Animal):\n    def speak(self):\n        return f\"{self.name} says woof!\"\n\ndog = Dog(\"Buddy\")\nprint(dog.speak())  # Output: Buddy says woof!"
  },
  {
    "objectID": "part-03/lecture-presentation.html#polymorphism",
    "href": "part-03/lecture-presentation.html#polymorphism",
    "title": "Lecture III - Building Reusable Functions",
    "section": "Polymorphism",
    "text": "Polymorphism\n\nPolymorphism allows you to use a single interface to represent different data types\nIt enables you to write more flexible and generic code"
  },
  {
    "objectID": "part-03/lecture-presentation.html#example-12",
    "href": "part-03/lecture-presentation.html#example-12",
    "title": "Lecture III - Building Reusable Functions",
    "section": "Example",
    "text": "Example\nclass Animal:\n    def speak(self):\n        pass\n\nclass Dog(Animal):\n    def speak(self):\n        return f\"{self.name} says woof!\"\n\nclass Cat(Animal):\n    def speak(self):\n        return f\"{self.name} says meow!\"\n\ndef make_animal_speak(animal):\n    print(animal.speak())\n\ndog = Dog(\"Buddy\")\ncat = Cat(\"Whiskers\")\n\nmake_animal_speak(dog)  # Output: Buddy says woof!\nmake_animal_speak(cat)  # Output: Whiskers says meow!"
  },
  {
    "objectID": "part-03/lecture-presentation.html#encapsulation",
    "href": "part-03/lecture-presentation.html#encapsulation",
    "title": "Lecture III - Building Reusable Functions",
    "section": "Encapsulation",
    "text": "Encapsulation\n\nEncapsulation is the concept of bundling data (attributes) and methods (behavior) that operate on the data into a single unit (class)\nIt helps in organizing code and controlling access to the internal parts of an object"
  },
  {
    "objectID": "part-03/lecture-presentation.html#example-13",
    "href": "part-03/lecture-presentation.html#example-13",
    "title": "Lecture III - Building Reusable Functions",
    "section": "Example",
    "text": "Example\nclass BankAccount:\n    def __init__(self, owner, balance=0):\n        self.owner = owner\n        self.balance = balance\n\n    def deposit(self, amount):\n        if amount &gt; 0:\n            self.balance += amount\n\n    def withdraw(self, amount):\n        if 0 &lt; amount &lt;= self.balance:\n            self.balance -= amount\n        else:\n            print(\"Insufficient funds!\")\n\naccount = BankAccount(\"Alice\", 100)\naccount.deposit(50)\naccount.withdraw(30)\nprint(account.balance)  # Output: 120"
  },
  {
    "objectID": "part-03/lecture-presentation.html#access-modifiers",
    "href": "part-03/lecture-presentation.html#access-modifiers",
    "title": "Lecture III - Building Reusable Functions",
    "section": "Access Modifiers",
    "text": "Access Modifiers\n\nIn Python, there are no strict access modifiers like in some other languages\nBy convention, you can use a single underscore _ to indicate that a variable or method is intended to be protected\nA double underscore __ is used to indicate that it is intended to be private"
  },
  {
    "objectID": "part-03/lecture-presentation.html#example-14",
    "href": "part-03/lecture-presentation.html#example-14",
    "title": "Lecture III - Building Reusable Functions",
    "section": "Example",
    "text": "Example\nclass BankAccount:\n    def __init__(self, owner, balance=0):\n        self.owner = owner\n        self.__balance = balance  # Private attribute\n\n    def deposit(self, amount):\n        if amount &gt; 0:\n            self.__balance += amount\n\n    def withdraw(self, amount):\n        if 0 &lt; amount &lt;= self.__balance:\n            self.__balance -= amount\n        else:\n            print(\"Insufficient funds!\")\n\naccount = BankAccount(\"Alice\", 100)\naccount.deposit(50)\naccount.withdraw(30)\nprint(account.balance)  # Output: 120"
  },
  {
    "objectID": "part-03/lecture-presentation.html#getters-and-setters",
    "href": "part-03/lecture-presentation.html#getters-and-setters",
    "title": "Lecture III - Building Reusable Functions",
    "section": "Getters and Setters",
    "text": "Getters and Setters\n\nGetters and setters are methods used to access and modify the attributes of a class\nThey provide controlled access to the attributes"
  },
  {
    "objectID": "part-03/lecture-presentation.html#example-15",
    "href": "part-03/lecture-presentation.html#example-15",
    "title": "Lecture III - Building Reusable Functions",
    "section": "Example",
    "text": "Example\nclass BankAccount:\n    def __init__(self, owner, balance=0):\n        self.owner = owner"
  },
  {
    "objectID": "part-03/lecture-presentation.html#getters-and-setters-1",
    "href": "part-03/lecture-presentation.html#getters-and-setters-1",
    "title": "Lecture III - Building Reusable Functions",
    "section": "Getters and Setters",
    "text": "Getters and Setters\n\nGetters are methods used to retrieve the value of an attribute\nSetters are methods used to modify the value of an attribute"
  },
  {
    "objectID": "part-03/lecture-presentation.html#example-16",
    "href": "part-03/lecture-presentation.html#example-16",
    "title": "Lecture III - Building Reusable Functions",
    "section": "Example",
    "text": "Example\nclass BankAccount:\n    def __init__(self, owner, balance=0):\n        self.owner = owner\n        self.__balance = balance  # Private attribute   \n\n    def get_balance(self):\n        return self.__balance\n\n    def set_balance(self, amount):\n        if amount &gt; 0:\n            self.__balance = amount\n        else:\n            print(\"Invalid amount!\")\n\n\n\nLecture III - Building Reusable Functions | Programming with Python | Dr. Tobias Vlćek | Home"
  },
  {
    "objectID": "part-03/lecture-presentation.html#some-built-in-functions-already-used",
    "href": "part-03/lecture-presentation.html#some-built-in-functions-already-used",
    "title": "Lecture III - Building Reusable Functions",
    "section": "Some Built-in Functions already used",
    "text": "Some Built-in Functions already used\n\nprint(): Print text to console\ninput(): Read text from console\nlen(): Get the length of a sequence\nrange(): Generate a sequence of numbers\nround(): Round a number to a specified number of decimal places\ntype(): Get the type of an object\nint(): Convert a string to an integer\nfloat(): Convert a string to a floating-point number\nstr(): Convert an object to a string"
  },
  {
    "objectID": "part-03/lecture-functions-presentation.html#what-is-a-function",
    "href": "part-03/lecture-functions-presentation.html#what-is-a-function",
    "title": "Lecture III - Building Reusable Functions",
    "section": "What is a Function?",
    "text": "What is a Function?\n\nFunctions can accept inputs (parameters) and return outputs\nEncapsulate logic, making code easier to maintain\nFunctions can be called multiple times from different part\nThey help reduce code duplication and improve readability\n\n\n# I'm a function.\ntype(print)\n\n\n\nbuiltin_function_or_method\n\n\n\n\n\n\n\n\n\nImportant\n\n\nRemember, methods are functions that are called on an object."
  },
  {
    "objectID": "part-03/lecture-functions-presentation.html#some-built-in-functions-already-used",
    "href": "part-03/lecture-functions-presentation.html#some-built-in-functions-already-used",
    "title": "Lecture III - Building Reusable Functions",
    "section": "Some Built-in Functions already used",
    "text": "Some Built-in Functions already used\n\nprint(): Print text to console\ninput(): Read text from console\nlen(): Get the length of a sequence\nrange(): Generate a sequence of numbers\nround(): Round a number to a specified number of decimal places\ntype(): Get the type of an object\nint(): Convert a string to an integer\nfloat(): Convert a string to a floating-point number\nstr(): Convert an object to a string"
  },
  {
    "objectID": "part-03/lecture-functions-presentation.html#defining-a-function",
    "href": "part-03/lecture-functions-presentation.html#defining-a-function",
    "title": "Lecture III - Building Reusable Functions",
    "section": "Defining a Function",
    "text": "Defining a Function\n\nUse the def keyword followed by the function name\nInside parentheses we list the inputs (parameters)\nThe code block within every function starts with a colon (:)\nIt is indented, just as the loops from the last lecture\n\n\n\ndef greet(a_parameter):\n    print(f\"Hello, {a_parameter}!\")\ngreet(\"Students\")\n\n\n\nHello, Students!\n\n\n\n\n\n\n\n\n\n\nTip\n\n\nIt is common practice to leave out one line after the definition of a function, although we will not always do that in the lecture to save space on the slides."
  },
  {
    "objectID": "part-03/lecture-functions-presentation.html#function-parameters",
    "href": "part-03/lecture-functions-presentation.html#function-parameters",
    "title": "Lecture III - Building Reusable Functions",
    "section": "Function Parameters",
    "text": "Function Parameters\n\nParameters are variables that the function accepts\nThey allow you to pass data to the function\nTry to name them as variables: short and meaningful\nWe can also leave them out or define several inputs!\n\n\ndef greet():\n    print(\"Hello, stranger!\")\ngreet()\n\n\n\nHello, stranger!"
  },
  {
    "objectID": "part-03/lecture-functions-presentation.html#example",
    "href": "part-03/lecture-functions-presentation.html#example",
    "title": "Lecture III - Building Reusable Functions",
    "section": "Example",
    "text": "Example\nclass BankAccount:\n    def __init__(self, owner, balance=0):\n        self.owner = owner\n        self.balance = balance\n\n    def deposit(self, amount):\n        if amount &gt; 0:\n            self.balance += amount\n\n    def withdraw(self, amount):\n        if 0 &lt; amount &lt;= self.balance:\n            self.balance -= amount\n        else:\n            print(\"Insufficient funds!\")\n\naccount = BankAccount(\"Alice\", 100)\naccount.deposit(50)\naccount.withdraw(30)\nprint(account.balance)  # Output: 120"
  },
  {
    "objectID": "part-03/lecture-functions-presentation.html#function-arguments",
    "href": "part-03/lecture-functions-presentation.html#function-arguments",
    "title": "Lecture III - Building Reusable Functions",
    "section": "Function Arguments",
    "text": "Function Arguments\n\nArguments are the actual values passed to the function\nThey replace the parameters in the function definition\n\n\n&gt; Question: What could be the correct arguments here?\n\ndef greet(university_name, lecture):\n    print(f\"Hello, students at the {university_name}!\")\n    print(f\"You are in lecture {lecture}!\")\n\n# Your code here"
  },
  {
    "objectID": "part-03/lecture-functions-presentation.html#example-1",
    "href": "part-03/lecture-functions-presentation.html#example-1",
    "title": "Lecture III - Building Reusable Functions",
    "section": "Example",
    "text": "Example\nclass BankAccount:\n    def __init__(self, owner, balance=0):\n        self.owner = owner\n        self.__balance = balance  # Private attribute\n\n    def deposit(self, amount):\n        if amount &gt; 0:\n            self.__balance += amount\n\n    def withdraw(self, amount):\n        if 0 &lt; amount &lt;= self.__balance:\n            self.__balance -= amount\n        else:\n            print(\"Insufficient funds!\")\n\naccount = BankAccount(\"Alice\", 100)\naccount.deposit(50)\naccount.withdraw(30)\nprint(account.balance)  # Output: 120"
  },
  {
    "objectID": "part-03/lecture-functions-presentation.html#function-return-values",
    "href": "part-03/lecture-functions-presentation.html#function-return-values",
    "title": "Lecture III - Building Reusable Functions",
    "section": "Function Return Values",
    "text": "Function Return Values\n\nFunctions can return values using the return statement\nThe return statement ends the function\nIt then returns the specified value\n\n\n\ndef simple_multiplication(a,b):\n    result = a*b\n    return result\nprint(simple_multiplication(2,21))\n\n\n\n42\n\n\n\n\n\ndef simple_multiplication(a,b):\n    return a*b # even shorter!\nprint(simple_multiplication(2,21))\n\n\n\n42"
  },
  {
    "objectID": "part-03/lecture-functions-presentation.html#example-2",
    "href": "part-03/lecture-functions-presentation.html#example-2",
    "title": "Lecture III - Building Reusable Functions",
    "section": "Example",
    "text": "Example\nclass BankAccount:\n    def __init__(self, owner, balance=0):\n        self.owner = owner"
  },
  {
    "objectID": "part-03/lecture-functions-presentation.html#function-scope",
    "href": "part-03/lecture-functions-presentation.html#function-scope",
    "title": "Lecture III - Building Reusable Functions",
    "section": "Function Scope",
    "text": "Function Scope\n\nVariables defined inside a function are local to that function\nThey cannot be accessed outside the function\n\n\ndef greet(name):\n    greeting = f\"Hello, {name}!\"\n    \nprint(greeting)  # This will cause an error\n\n\n&gt; Question: Any idea how to access greeting?"
  },
  {
    "objectID": "part-03/lecture-functions-presentation.html#global-scope",
    "href": "part-03/lecture-functions-presentation.html#global-scope",
    "title": "Lecture III - Building Reusable Functions",
    "section": "Global Scope",
    "text": "Global Scope\n\nVariables defined outside all functions are in the global scope\nThey can be accessed from anywhere in the program\n\n\n\ngreeting = \"Hello, Stranger!\"\ndef greet(name):\n   greeting = f\"Hello, {name}!\"\n   return greeting\nprint(greet(\"Students\")) # Greet students\nprint(greeting) # Greet ????\n\n\n\nHello, Students!\nHello, Stranger!\n\n\n\n\n\n\n\n\n\n\nImportant\n\n\nWe don’t change global variables inside a function! The original value can still be accessed from outside the function."
  },
  {
    "objectID": "part-03/lecture-functions-presentation.html#example-3",
    "href": "part-03/lecture-functions-presentation.html#example-3",
    "title": "Lecture III - Building Reusable Functions",
    "section": "Example",
    "text": "Example\nclass BankAccount:\n    def __init__(self, owner, balance=0):\n        self.owner = owner\n        self.__balance = balance  # Private attribute   \n\n    def get_balance(self):\n        return self.__balance\n\n    def set_balance(self, amount):\n        if amount &gt; 0:\n            self.__balance = amount\n        else:\n            print(\"Invalid amount!\")\n\n\n\nLecture III - Building Reusable Functions | Programming with Python | Dr. Tobias Vlćek | Home"
  },
  {
    "objectID": "part-03/lecture-functions-presentation.html#local-scope",
    "href": "part-03/lecture-functions-presentation.html#local-scope",
    "title": "Lecture III - Building Reusable Functions",
    "section": "Local Scope",
    "text": "Local Scope\n\nVariables defined inside a function are in the local scope\nThey can only be accessed within that function"
  },
  {
    "objectID": "part-03/lecture-functions-presentation.html#example-4",
    "href": "part-03/lecture-functions-presentation.html#example-4",
    "title": "Lecture III - Building Reusable Functions",
    "section": "Example",
    "text": "Example\nclass BankAccount:\n    def __init__(self, owner, balance=0):\n        self.owner = owner"
  },
  {
    "objectID": "part-03/lecture-functions-presentation.html#global-keyword",
    "href": "part-03/lecture-functions-presentation.html#global-keyword",
    "title": "Lecture III - Building Reusable Functions",
    "section": "Global Keyword",
    "text": "Global Keyword\n\nStill, we can change the value of greeting from inside a function!\nBy using the global keyword to modify a global variable\n\n\n\ngreeting = \"Hello, Stranger!\"\n\ndef greet(name):\n   global greeting\n   greeting = f\"Hello, {name}!\"\n   return greeting\n\nprint(greet(\"Students\")) # Greet students\nprint(greeting) # Greet students again\n\n\n\nHello, Students!\nHello, Students!\n\n\n\n\n&gt;Question: This can be confusing. Do you think you got the idea?"
  },
  {
    "objectID": "part-03/lecture-functions-presentation.html#example-5",
    "href": "part-03/lecture-functions-presentation.html#example-5",
    "title": "Lecture III - Building Reusable Functions",
    "section": "Example",
    "text": "Example\nclass BankAccount:\n    def __init__(self, owner, balance=0):\n        self.owner = owner\n        self.__balance = balance  # Private attribute   \n\n    def get_balance(self):\n        return self.__balance\n\n    def set_balance(self, amount):\n        if amount &gt; 0:\n            self.__balance = amount\n        else:\n            print(\"Invalid amount!\")\n\n\n\nLecture III - Building Reusable Functions | Programming with Python | Dr. Tobias Vlćek | Home"
  },
  {
    "objectID": "part-03/lecture-functions-presentation.html#built-in-functions",
    "href": "part-03/lecture-functions-presentation.html#built-in-functions",
    "title": "Lecture III - Building Reusable Functions",
    "section": "Built-in Functions",
    "text": "Built-in Functions\n\nPython has many built-in functions that are always available\nExamples include print(), len(), range(), max(), min(), etc."
  },
  {
    "objectID": "part-03/lecture-functions-presentation.html#example-6",
    "href": "part-03/lecture-functions-presentation.html#example-6",
    "title": "Lecture III - Building Reusable Functions",
    "section": "Example",
    "text": "Example\nclass BankAccount:\n    def __init__(self, owner, balance=0):\n        self.owner = owner\n        self.__balance = balance  # Private attribute   \n\n    def get_balance(self):\n        return self.__balance\n\n    def set_balance(self, amount):\n        if amount &gt; 0:\n            self.__balance = amount\n        else:\n            print(\"Invalid amount!\")\n\n\n\nLecture III - Building Reusable Functions | Programming with Python | Dr. Tobias Vlćek | Home"
  },
  {
    "objectID": "part-03/lecture-functions-presentation.html#classes-1",
    "href": "part-03/lecture-functions-presentation.html#classes-1",
    "title": "Lecture III - Building Reusable Functions",
    "section": "Classes",
    "text": "Classes\n\nClasses are blueprints for creating objects\nThey encapsulate data (attributes) and behavior (methods)\nObjects are instances of classes\nMethods are functions that are defined within a class\n\n\n\nclass Students: # Class definition\n    def know_answer(self): # Method definition\n        print(f\"They know the answer to all questions.\")\n\nstudent = Students() # Object instantiation\nstudent.know_answer()\n\n\n\nThey know the answer to all questions."
  },
  {
    "objectID": "part-03/lecture-functions-presentation.html#example-7",
    "href": "part-03/lecture-functions-presentation.html#example-7",
    "title": "Lecture III - Building Reusable Functions",
    "section": "Example",
    "text": "Example\nclass BankAccount:\n    def __init__(self, owner, balance=0):\n        self.owner = owner\n        self.__balance = balance  # Private attribute   \n\n    def get_balance(self):\n        return self.__balance\n\n    def set_balance(self, amount):\n        if amount &gt; 0:\n            self.__balance = amount\n        else:\n            print(\"Invalid amount!\")\n\n\n\nLecture III - Building Reusable Functions | Programming with Python | Dr. Tobias Vlćek | Home"
  },
  {
    "objectID": "part-03/lecture-functions-presentation.html#class-attributes",
    "href": "part-03/lecture-functions-presentation.html#class-attributes",
    "title": "Lecture III - Building Reusable Functions",
    "section": "Class Attributes",
    "text": "Class Attributes\n\nClass attributes are attributes that are shared by all class instances\nThey are defined within the class but outside any methods\n\n\n&gt;Question: What do you think will happen here?\n\nclass Students: # Class definition\n    smart = True # Class attribute\n\nstudent_A = Students() # Object instantiation student_A\nstudent_B = Students() # Object instantiation student_B\n\nprint(student_A.smart)\nprint(student_B.smart)\n\n\n\nTrue\nTrue"
  },
  {
    "objectID": "part-03/lecture-functions-presentation.html#example-8",
    "href": "part-03/lecture-functions-presentation.html#example-8",
    "title": "Lecture III - Building Reusable Functions",
    "section": "Example",
    "text": "Example\nclass BankAccount:\n    def __init__(self, owner, balance=0):\n        self.owner = owner\n        self.__balance = balance  # Private attribute   \n\n    def get_balance(self):\n        return self.__balance\n\n    def set_balance(self, amount):\n        if amount &gt; 0:\n            self.__balance = amount\n        else:\n            print(\"Invalid amount!\")\n\n\n\nLecture III - Building Reusable Functions | Programming with Python | Dr. Tobias Vlćek | Home"
  },
  {
    "objectID": "part-03/lecture-functions-presentation.html#instance-attributes",
    "href": "part-03/lecture-functions-presentation.html#instance-attributes",
    "title": "Lecture III - Building Reusable Functions",
    "section": "Instance Attributes",
    "text": "Instance Attributes\n\nInstance attributes are attributes unique to each class instance\nThey are defined within the __init__ method\n\n\nclass Student: # Class definition\n    def __init__(self, name, is_smart): # Method for initalization\n        self.name = name\n        self.smart = is_smart\n    def knows_answer(self): # Method to be called\n        if self.smart:\n            print(f\"{self.name} knows the answer to the question.\")\n        else:\n            print(f\"{self.name} does not know the answer to the question.\")\n\nstudent = Student(\"Buddy\",False) # Note, we don't need to call self here!\nstudent.knows_answer()\n\n\n\nBuddy does not know the answer to the question."
  },
  {
    "objectID": "part-03/lecture-functions-presentation.html#example-9",
    "href": "part-03/lecture-functions-presentation.html#example-9",
    "title": "Lecture III - Building Reusable Functions",
    "section": "Example",
    "text": "Example\nclass BankAccount:\n    def __init__(self, owner, balance=0):\n        self.owner = owner\n        self.__balance = balance  # Private attribute   \n\n    def get_balance(self):\n        return self.__balance\n\n    def set_balance(self, amount):\n        if amount &gt; 0:\n            self.__balance = amount\n        else:\n            print(\"Invalid amount!\")\n\n\n\nLecture III - Building Reusable Functions | Programming with Python | Dr. Tobias Vlćek | Home"
  },
  {
    "objectID": "part-03/lecture-functions-presentation.html#methods",
    "href": "part-03/lecture-functions-presentation.html#methods",
    "title": "Lecture III - Building Reusable Functions",
    "section": "Methods",
    "text": "Methods\n\nMethods are functions that are defined within a class\nThey operate on the instance attributes of the class"
  },
  {
    "objectID": "part-03/lecture-functions-presentation.html#example-10",
    "href": "part-03/lecture-functions-presentation.html#example-10",
    "title": "Lecture III - Building Reusable Functions",
    "section": "Example",
    "text": "Example\nclass BankAccount:\n    def __init__(self, owner, balance=0):\n        self.owner = owner\n        self.__balance = balance  # Private attribute   \n\n    def get_balance(self):\n        return self.__balance\n\n    def set_balance(self, amount):\n        if amount &gt; 0:\n            self.__balance = amount\n        else:\n            print(\"Invalid amount!\")\n\n\n\nLecture III - Building Reusable Functions | Programming with Python | Dr. Tobias Vlćek | Home"
  },
  {
    "objectID": "part-03/lecture-functions-presentation.html#inheritance",
    "href": "part-03/lecture-functions-presentation.html#inheritance",
    "title": "Lecture III - Building Reusable Functions",
    "section": "Inheritance",
    "text": "Inheritance\n\nInheritance allows a class to inherit attributes and methods\nThe class that inherits is called the subclass\nThe class that is being inherited from is called the superclass\n\n\n\n\n\n\n\n\nTip\n\n\nDon’t worry!  It can be quite much right now. Hang in there and soon it will get easier again!"
  },
  {
    "objectID": "part-03/lecture-functions-presentation.html#example-11",
    "href": "part-03/lecture-functions-presentation.html#example-11",
    "title": "Lecture III - Building Reusable Functions",
    "section": "Example",
    "text": "Example\nclass BankAccount:\n    def __init__(self, owner, balance=0):\n        self.owner = owner\n        self.__balance = balance  # Private attribute   \n\n    def get_balance(self):\n        return self.__balance\n\n    def set_balance(self, amount):\n        if amount &gt; 0:\n            self.__balance = amount\n        else:\n            print(\"Invalid amount!\")\n\n\n\nLecture III - Building Reusable Functions | Programming with Python | Dr. Tobias Vlćek | Home"
  },
  {
    "objectID": "part-03/lecture-functions-presentation.html#polymorphism",
    "href": "part-03/lecture-functions-presentation.html#polymorphism",
    "title": "Lecture III - Building Reusable Functions",
    "section": "Polymorphism",
    "text": "Polymorphism\n\nPolymorphism allows you to use a single interface to represent different data types\nIt enables you to write more flexible and generic code"
  },
  {
    "objectID": "part-03/lecture-functions-presentation.html#example-12",
    "href": "part-03/lecture-functions-presentation.html#example-12",
    "title": "Lecture III - Building Reusable Functions",
    "section": "Example",
    "text": "Example\nclass BankAccount:\n    def __init__(self, owner, balance=0):\n        self.owner = owner"
  },
  {
    "objectID": "part-03/lecture-functions-presentation.html#encapsulation",
    "href": "part-03/lecture-functions-presentation.html#encapsulation",
    "title": "Lecture III - Building Reusable Functions",
    "section": "Encapsulation",
    "text": "Encapsulation\n\nEncapsulation is the concept of bundling data (attributes) and methods (behavior) that operate on the data into a single unit (class)\nIt is a key aspect of object oriented programming (OOP)\nIt helps in organizing code and controlling access\n\n\n\n\n\n\n\n\nNote\n\n\nFortunately, this is an introduction to Python, so we won’t go into details of encapsulation."
  },
  {
    "objectID": "part-03/lecture-functions-presentation.html#example-13",
    "href": "part-03/lecture-functions-presentation.html#example-13",
    "title": "Lecture III - Building Reusable Functions",
    "section": "Example",
    "text": "Example\nclass BankAccount:\n    def __init__(self, owner, balance=0):\n        self.owner = owner\n        self.__balance = balance  # Private attribute   \n\n    def get_balance(self):\n        return self.__balance\n\n    def set_balance(self, amount):\n        if amount &gt; 0:\n            self.__balance = amount\n        else:\n            print(\"Invalid amount!\")\n\n\n\nLecture III - Building Reusable Functions | Programming with Python | Dr. Tobias Vlćek | Home"
  },
  {
    "objectID": "part-03/lecture-functions-presentation.html#access-modifiers",
    "href": "part-03/lecture-functions-presentation.html#access-modifiers",
    "title": "Lecture III - Building Reusable Functions",
    "section": "Access Modifiers",
    "text": "Access Modifiers\n\nIn Python, there are no strict access modifiers like in some other languages\nBy convention, you can use a single underscore _ to indicate that a variable or method is intended to be protected\nA double underscore __ is used to indicate that it is intended to be private"
  },
  {
    "objectID": "part-03/lecture-functions-presentation.html#example-14",
    "href": "part-03/lecture-functions-presentation.html#example-14",
    "title": "Lecture III - Building Reusable Functions",
    "section": "Example",
    "text": "Example\nclass BankAccount:\n    def __init__(self, owner, balance=0):\n        self.owner = owner\n        self.__balance = balance  # Private attribute   \n\n    def get_balance(self):\n        return self.__balance\n\n    def set_balance(self, amount):\n        if amount &gt; 0:\n            self.__balance = amount\n        else:\n            print(\"Invalid amount!\")\n\n\n\nLecture III - Building Reusable Functions | Programming with Python | Dr. Tobias Vlćek | Home"
  },
  {
    "objectID": "part-03/lecture-functions-presentation.html#getters-and-setters",
    "href": "part-03/lecture-functions-presentation.html#getters-and-setters",
    "title": "Lecture III - Building Reusable Functions",
    "section": "Getters and Setters",
    "text": "Getters and Setters\n\nGetters and setters are methods used to access and modify the attributes of a class\nThey provide controlled access to the attributes"
  },
  {
    "objectID": "part-03/lecture-functions-presentation.html#example-15",
    "href": "part-03/lecture-functions-presentation.html#example-15",
    "title": "Lecture III - Building Reusable Functions",
    "section": "Example",
    "text": "Example\nclass BankAccount:\n    def __init__(self, owner, balance=0):\n        self.owner = owner\n        self.__balance = balance  # Private attribute   \n\n    def get_balance(self):\n        return self.__balance\n\n    def set_balance(self, amount):\n        if amount &gt; 0:\n            self.__balance = amount\n        else:\n            print(\"Invalid amount!\")\n\n\n\nLecture III - Building Reusable Functions | Programming with Python | Dr. Tobias Vlćek | Home"
  },
  {
    "objectID": "part-03/lecture-functions-presentation.html#getters-and-setters-1",
    "href": "part-03/lecture-functions-presentation.html#getters-and-setters-1",
    "title": "Lecture III - Building Reusable Functions",
    "section": "Getters and Setters",
    "text": "Getters and Setters\n\nGetters are methods used to retrieve the value of an attribute\nSetters are methods used to modify the value of an attribute"
  },
  {
    "objectID": "part-03/lecture-functions-presentation.html#example-16",
    "href": "part-03/lecture-functions-presentation.html#example-16",
    "title": "Lecture III - Building Reusable Functions",
    "section": "Example",
    "text": "Example\nclass BankAccount:\n    def __init__(self, owner, balance=0):\n        self.owner = owner\n        self.__balance = balance  # Private attribute   \n\n    def get_balance(self):\n        return self.__balance\n\n    def set_balance(self, amount):\n        if amount &gt; 0:\n            self.__balance = amount\n        else:\n            print(\"Invalid amount!\")\n\n\n\nLecture III - Building Reusable Functions | Programming with Python | Dr. Tobias Vlćek | Home"
  },
  {
    "objectID": "part-03/lecture-functions-presentation.html#comparison-operators",
    "href": "part-03/lecture-functions-presentation.html#comparison-operators",
    "title": "Lecture III - Building Reusable Functions",
    "section": "Comparison Operators",
    "text": "Comparison Operators\n\nComparison operators are used to compare two values\nThe result of a comparison is a boolean value (True or False)\nOperators include: ==, !=, &gt;, &lt;, &gt;=, &lt;=\n\n\n&gt; Question: Is this True?\n\n# Careful here!\none = 1\ntwo = 1\nprint(one == two)\n\n\n\nTrue"
  },
  {
    "objectID": "part-03/lecture-functions-presentation.html#control-structures",
    "href": "part-03/lecture-functions-presentation.html#control-structures",
    "title": "Lecture III - Building Reusable Functions",
    "section": "Control Structures",
    "text": "Control Structures\n\nControl structures allow us to control the flow of execution\nIt includes conditional statements and loops\nConditional statements: if, elif, else\nLoops: for and while\nControl flow statements (in loops): continue and break\n\n\n\n\n\n\n\n\nNote\n\n\nThe statement continue skips the rest of the current iteration and moves to the next one in a loop while the break statement exits the loop entirely."
  },
  {
    "objectID": "part-03/lecture-functions-presentation.html#slicing",
    "href": "part-03/lecture-functions-presentation.html#slicing",
    "title": "Lecture III - Building Reusable Functions",
    "section": "Slicing",
    "text": "Slicing\n\nWith slicing we can get a range of elements from a sequence\nSyntax: sequence[start:stop:step]\nstart is the index of the first element to include\nstop is the index of the first element to exclude\nstep is the increment between indices\n\n\n\n\n\n\n\n\nTip\n\n\nIf left out, the step defaults to 1. Else, start defaults to 0 and stop defaults to the length of the sequence. Negative indices can be used to slice from the end of the sequence."
  },
  {
    "objectID": "part-03/lecture-functions-presentation.html#naming-functions-and-methods",
    "href": "part-03/lecture-functions-presentation.html#naming-functions-and-methods",
    "title": "Lecture III - Building Reusable Functions",
    "section": "Naming Functions (and Methods)",
    "text": "Naming Functions (and Methods)\n\nFunction names should be short, but descriptive\nUse underscores (_) instead of spaces in the names\nAvoid using Python keywords as function names (e.g., print)\nTry to avoid using built-in functions and methods that have a similar name (e.g., sum and len)\n\n&gt; Question: Which of the following is a good name for a function?\n\n\nmyfunctionthatmultipliesvalues \nmultiply_two_values\n\nmultiplyTwoValues"
  },
  {
    "objectID": "part-03/lecture-functions-presentation.html#returning-none",
    "href": "part-03/lecture-functions-presentation.html#returning-none",
    "title": "Lecture III - Building Reusable Functions",
    "section": "Returning None",
    "text": "Returning None\n\nIf we don’t specify return, functions will return None\n\n\ndef simple_multiplication(a,b):\n    result = a*b\n\nprint(simple_multiplication(2,21))\n\n\n\nNone\n\n\n\n&gt; Grouptask: Come up with a function that checks whether a number is positive or negative. It returns \"positive\" for positive numbers and \"negative\" for negative numbers.\n\n\n\n\n\n\n\n\nTip\n\n\nYou can also use multiple return statements in a function."
  },
  {
    "objectID": "part-03/lecture-functions-presentation.html#global-scope-1",
    "href": "part-03/lecture-functions-presentation.html#global-scope-1",
    "title": "Lecture III - Building Reusable Functions",
    "section": "Global Scope",
    "text": "Global Scope\n\nVariables defined outside all functions are in the global scope\nThey can be accessed from anywhere in the program\n\n\ngreeting = \"Hello, Stranger!\"\n\ndef greet(name):\n   greeting = f\"Hello, {name}!\"\n   return greeting\n\nprint(greeting) # Greet Stranger\n\n\n\nHello, Stranger!\n\n\n\n\n\n\n\n\nWarning\n\n\nThe variable greeting is not changed within the function!\n\nGlobal Keyword\n\nUse the global keyword to modify a global variable inside a function\n\n\n\nExample\ndef modify_global():\n    global name\n    name = \"Bob\"\n\nmodify_global()\nprint(name)  # Output: Bob\n\n\nClasses\n\n\n\nClasses\n\nClasses are blueprints for creating objects\nThey encapsulate data (attributes) and behavior (methods)\nObjects are instances of classes\n\n\n\nExample\nclass Dog:\n    def __init__(self, name):\n        self.name = name\n\n    def bark(self):\n        print(f\"{self.name} says woof!\")\n\ndog = Dog(\"Buddy\")\ndog.bark()  # Output: Buddy says woof!\n\n\nClass Attributes\n\nClass attributes are attributes that are shared by all instances of a class\nThey are defined within the class but outside any methods\n\n\n\nExample\nclass Dog:\n    species = \"Canis familiaris\"\n\ndog1 = Dog()\ndog2 = Dog()\n\nprint(dog1.species)  # Output: Canis familiaris\nprint(dog2.species)  # Output: Canis familiaris\n\n\nInstance Attributes\n\nInstance attributes are attributes that are unique to each instance of a class\nThey are defined within the __init__ method\n\n\n\nExample\nclass Dog:\n    def __init__(self, name):\n        self.name = name\n\ndog1 = Dog(\"Buddy\")\ndog2 = Dog(\"Max\")\n\nprint(dog1.name)  # Output: Buddy\nprint(dog2.name)  # Output: Max\n\n\nMethods\n\nMethods are functions that are defined within a class\nThey operate on the instance attributes of the class\n\n\n\nExample\nclass Dog:\n    def __init__(self, name):\n        self.name = name\n\n    def bark(self):\n        print(f\"{self.name} says woof!\")\n\ndog = Dog(\"Buddy\")\ndog.bark()  # Output: Buddy says woof!\n\n\nInheritance\n\nInheritance allows a class to inherit attributes and methods from another class\nThe class that inherits is called the subclass, and the class being inherited from is the superclass\n\n\n\nExample\nclass Animal:\n    def __init__(self, name):\n        self.name = name\n\n    def speak(self):\n        pass\n\nclass Dog(Animal):\n    def speak(self):\n        return f\"{self.name} says woof!\"\n\ndog = Dog(\"Buddy\")\nprint(dog.speak())  # Output: Buddy says woof!\n\n\nPolymorphism\n\nPolymorphism allows you to use a single interface to represent different data types\nIt enables you to write more flexible and generic code\n\n\n\nExample\nclass Animal:\n    def speak(self):\n        pass\n\nclass Dog(Animal):\n    def speak(self):\n        return f\"{self.name} says woof!\"\n\nclass Cat(Animal):\n    def speak(self):\n        return f\"{self.name} says meow!\"\n\ndef make_animal_speak(animal):\n    print(animal.speak())\n\ndog = Dog(\"Buddy\")\ncat = Cat(\"Whiskers\")\n\nmake_animal_speak(dog)  # Output: Buddy says woof!\nmake_animal_speak(cat)  # Output: Whiskers says meow!\n\n\nEncapsulation\n\nEncapsulation is the concept of bundling data (attributes) and methods (behavior) that operate on the data into a single unit (class)\nIt helps in organizing code and controlling access to the internal parts of an object\n\n\n\nExample\nclass BankAccount:\n    def __init__(self, owner, balance=0):\n        self.owner = owner\n        self.balance = balance\n\n    def deposit(self, amount):\n        if amount &gt; 0:\n            self.balance += amount\n\n    def withdraw(self, amount):\n        if 0 &lt; amount &lt;= self.balance:\n            self.balance -= amount\n        else:\n            print(\"Insufficient funds!\")\n\naccount = BankAccount(\"Alice\", 100)\naccount.deposit(50)\naccount.withdraw(30)\nprint(account.balance)  # Output: 120\n\n\nAccess Modifiers\n\nIn Python, there are no strict access modifiers like in some other languages\nBy convention, you can use a single underscore _ to indicate that a variable or method is intended to be protected\nA double underscore __ is used to indicate that it is intended to be private\n\n\n\nExample\nclass BankAccount:\n    def __init__(self, owner, balance=0):\n        self.owner = owner\n        self.__balance = balance  # Private attribute\n\n    def deposit(self, amount):\n        if amount &gt; 0:\n            self.__balance += amount\n\n    def withdraw(self, amount):\n        if 0 &lt; amount &lt;= self.__balance:\n            self.__balance -= amount\n        else:\n            print(\"Insufficient funds!\")\n\naccount = BankAccount(\"Alice\", 100)\naccount.deposit(50)\naccount.withdraw(30)\nprint(account.balance)  # Output: 120\n\n\nGetters and Setters\n\nGetters and setters are methods used to access and modify the attributes of a class\nThey provide controlled access to the attributes\n\n\n\nExample\nclass BankAccount:\n    def __init__(self, owner, balance=0):\n        self.owner = owner\n\n\nGetters and Setters\n\nGetters are methods used to retrieve the value of an attribute\nSetters are methods used to modify the value of an attribute\n\n\n\nExample\nclass BankAccount:\n    def __init__(self, owner, balance=0):\n        self.owner = owner\n        self.__balance = balance  # Private attribute   \n\n    def get_balance(self):\n        return self.__balance\n\n    def set_balance(self, amount):\n        if amount &gt; 0:\n            self.__balance = amount\n        else:\n            print(\"Invalid amount!\")\n\n\n\nLecture III - Building Reusable Functions | Programming with Python | Dr. Tobias Vlćek | Home"
  },
  {
    "objectID": "part-03/lecture-functions-presentation.html#section",
    "href": "part-03/lecture-functions-presentation.html#section",
    "title": "Lecture III - Building Reusable Functions",
    "section": "",
    "text": "class Student: # We define a class with the keyword class\n    def __init__(self, name): # A method called when an object is created\n        self.name = name\n\n    def knows_answer(self): # A method that prints out the string\n        print(f\"{self.name} knows the answer to the question.\")\n\nstudent = Student(\"Buddy\")\nstudent.knows_answer()\n\n\n\nBuddy knows the answer to the question."
  },
  {
    "objectID": "part-03/lecture-functions-presentation.html#global-scope-ii",
    "href": "part-03/lecture-functions-presentation.html#global-scope-ii",
    "title": "Lecture III - Building Reusable Functions",
    "section": "Global Scope II",
    "text": "Global Scope II\n\nWe don’t change global variables inside a function!\nThe original value can still be accessed from outside the function\n\n\ngreeting = \"Hello, Stranger!\"\n\ndef greet(name):\n   greeting = f\"Hello, {name}!\"\n   return greeting\n\nprint(greet(\"Students\")) # Greet students\nprint(greeting) # Greet Stranger\n\n\n\nHello, Students!\nHello, Stranger!"
  },
  {
    "objectID": "part-03/lecture-functions-presentation.html#scope-of-loops",
    "href": "part-03/lecture-functions-presentation.html#scope-of-loops",
    "title": "Lecture III - Building Reusable Functions",
    "section": "Scope of Loops",
    "text": "Scope of Loops\n\nThe variable scope in loops works like in functions\nVariables defined inside loops are scoped to that loop\nVariables defined in the global scope can be accessed by any loop\n\n\n\n# This won't work!\nfor i in range(3):\n    number_everywhere = \"Number\"\n    print(number_everywhere,i)\n\nprint(number_everywhere)\n\n\n\nNumber 0\nNumber 1\nNumber 2\nNumber"
  },
  {
    "objectID": "part-03/lecture-functions-presentation.html#change-varables-in-global-scope",
    "href": "part-03/lecture-functions-presentation.html#change-varables-in-global-scope",
    "title": "Lecture III - Building Reusable Functions",
    "section": "Change Varables in Global Scope",
    "text": "Change Varables in Global Scope\n\nWe don’t change global variables inside a function!\nThe original value can still be accessed from outside the function\n\n\ngreeting = \"Hello, Stranger!\"\n\ndef greet(name):\n   greeting = f\"Hello, {name}!\"\n   return greeting\n\nprint(greet(\"Students\")) # Greet students\nprint(greeting) # Greet Stranger\n\n\n\nHello, Students!\nHello, Stranger!"
  },
  {
    "objectID": "part-03/lecture-functions-presentation.html#change-variables-in-global-scope",
    "href": "part-03/lecture-functions-presentation.html#change-variables-in-global-scope",
    "title": "Lecture III - Building Reusable Functions",
    "section": "Change Variables in Global Scope",
    "text": "Change Variables in Global Scope\n\nWe don’t change global variables inside a function!\nThe original value can still be accessed from outside the function\n\n\ngreeting = \"Hello, Stranger!\"\n\ndef greet(name):\n   greeting = f\"Hello, {name}!\"\n   return greeting\n\nprint(greet(\"Students\")) # Greet students\nprint(greeting) # Greet Stranger\n\n\n\nHello, Students!\nHello, Stranger!"
  },
  {
    "objectID": "part-03/lecture-functions-presentation.html#self",
    "href": "part-03/lecture-functions-presentation.html#self",
    "title": "Lecture III - Building Reusable Functions",
    "section": "Self",
    "text": "Self\n\nClasses can be quite tricky at first, especially the self keyword\nWhen we call self in a method, it refers to the object itself\nIt is used to access the attributes and methods of the class\nself always needs to be included in method definitions\n\n\n\n# This won't work as self is missing\nclass Students: # Class definition\n    def know_answer(): # Method definition without self\n        print(f\"They know the answer to all questions.\")\n\nstudent = Students()\nstudent.know_answer()\n\n\n\n&gt;Task: Try it yourself, what is the error?"
  },
  {
    "objectID": "part-03/lecture-functions-presentation.html#inheritance-in-action",
    "href": "part-03/lecture-functions-presentation.html#inheritance-in-action",
    "title": "Lecture III - Building Reusable Functions",
    "section": "Inheritance in Action",
    "text": "Inheritance in Action\n\nclass Student: # Superclass\n    def __init__(self, name):\n        self.name = name\n    def when_asked(self):\n        pass\n\nclass SmartStudent(Student): # Subclass\n    def when_asked(self):\n        return f\"{self.name} knows the answer!\"\n        \nclass LazyStudent(Student): # Subclass\n    def when_asked(self):\n        return f\"{self.name} has to ask ChatGPT!\"\n\n&gt;Grouptask: Create two students. One is smart and the other one is lazy. Make sure that both students reaction to a question is printed."
  },
  {
    "objectID": "part-03/lecture-functions-presentation.html#access-return-values",
    "href": "part-03/lecture-functions-presentation.html#access-return-values",
    "title": "Lecture III - Building Reusable Functions",
    "section": "Access return values",
    "text": "Access return values\n\nWe can also save the return value from a function in a variable\nThat way we can use it later on in the program\n\n\n\ndef simple_multiplication(a,b):\n    return a*b # even shorter!\n\nresult = simple_multiplication(2,21)\nprint(result)\n\n\n\n42"
  },
  {
    "objectID": "part-03/lecture-functions-presentation.html#empty-functions",
    "href": "part-03/lecture-functions-presentation.html#empty-functions",
    "title": "Lecture III - Building Reusable Functions",
    "section": "Empty Functions",
    "text": "Empty Functions\n\nA function without any code is called an “empty” function\nTo define it we have to use the pass keyword\nIt does nothing and is used as a placeholder for future code\nIt is good practice to include a comment at the top of your functions\nIf you do it with three dashes, it will appear in the help menu\n\n\n\ndef greet():\n    \"\"\"\n    This function will be used later and has currently\n    absolutely no use for anything.\n    \"\"\"\n    pass\n\nhelp(greet)\n\n\n\nHelp on function greet in module __main__:\n\ngreet()\n    This function will be used later and has currently\n    absolutely no use for anything.\n\n\n\n\n\n\n\n\n\n\n\nTip\n\n\nIt is common practice to leave out one line after the definition of a function, although we will not always do that in the lecture to save space on the slides."
  },
  {
    "objectID": "part-03/lecture-functions-presentation.html#comment-functions",
    "href": "part-03/lecture-functions-presentation.html#comment-functions",
    "title": "Lecture III - Building Reusable Functions",
    "section": "Comment Functions",
    "text": "Comment Functions\n\nIt is good practice to include a comment at the top of your functions\nIf you do it with three \"\"\", it will appear in the help menu\n\n\n\ndef greet():\n    \"\"\"\n    This function will be used later and has currently\n    absolutely no use for anything.\n    \"\"\"\n    pass # Necessary placeholder to avoid error\n\nhelp(greet)\n\n\n\nHelp on function greet in module __main__:\n\ngreet()\n    This function will be used later and has currently\n    absolutely no use for anything."
  },
  {
    "objectID": "part-03/lecture-functions-presentation.html#naming-classes",
    "href": "part-03/lecture-functions-presentation.html#naming-classes",
    "title": "Lecture III - Building Reusable Functions",
    "section": "Naming Classes",
    "text": "Naming Classes\n\nClasses can be named anything, but it is common to use the plural form of their name (e.g., People)\nCamelCase is used for class names, and snake_case is used for method and attribute names (e.g., TallPeople)\nClasses are usually defined in a file with the same name as their class, but with a .py extension\n\n\nQuestion: Which of the following is a good class name? smart_student, SmartStudent, or SmartStudents"
  },
  {
    "objectID": "part-03/lecture-functions-presentation.html#initializing-parameters",
    "href": "part-03/lecture-functions-presentation.html#initializing-parameters",
    "title": "Lecture III - Building Reusable Functions",
    "section": "Initializing Parameters",
    "text": "Initializing Parameters\n\nWe can also initialize parameters to a default value!\nTo do this we use the = sign and provide it with a value\nThis is called a keyword argument\n\n\ndef greet(lecture=\"Programming with Python\"):\n    print(f\"You are in lecture '{lecture}'!\")\n\ngreet()\ngreet(\"Super Advanced Programming with Python\")\n\n\n\nYou are in lecture 'Programming with Python'!\nYou are in lecture 'Super Advanced Programming with Python'!\n\n\n\n\n\n\n\n\n\nTip\n\n\nThis is especially useful when we want to avoid errors due to missing arguments!"
  },
  {
    "objectID": "part-03/lecture-functions-presentation.html#the-end",
    "href": "part-03/lecture-functions-presentation.html#the-end",
    "title": "Lecture III - Building Reusable Functions",
    "section": "The End",
    "text": "The End\n\nInterested in more detail about classes and OOP?\nCheck out access modifiers, getters and setters\nThey are definitely a bit more complicated for beginners…\nThough they are worth learning if you build complex programs\n\n\n\n\n\n\n\n\nNote\n\n\nAnd that’s it for todays lecture!\nWe now have covered the basics of funtions and classes. We will continue with some slightly easier topics in the next lectures.\n\n\n\nLiterature {.title}"
  },
  {
    "objectID": "part-03/lecture-functions-presentation.html#interesting-books-to-dive-deeper",
    "href": "part-03/lecture-functions-presentation.html#interesting-books-to-dive-deeper",
    "title": "Lecture III - Building Reusable Functions",
    "section": "Interesting Books to dive deeper",
    "text": "Interesting Books to dive deeper\n\nThomas, D., & Hunt, A. (2019). The pragmatic programmer, 20th anniversary edition: Journey to mastery (Second edition). Addison-Wesley.\n\n\n\n\n\n\n\n\nTip\n\n\nA fantastic textbook to understand the principles of modern software development and how to create effective software.\n\n\n\n\n\nFor more interesting literature to learn more about Python, take a look at the literature list of this course.\n\n\n\nLecture III - Building Reusable Functions | Programming with Python | Dr. Tobias Vlćek | Home"
  },
  {
    "objectID": "part-03/lecture-functions-presentation.html#interesting-book-to-dive-deeper",
    "href": "part-03/lecture-functions-presentation.html#interesting-book-to-dive-deeper",
    "title": "Lecture III - Building Reusable Functions",
    "section": "Interesting Book to dive deeper",
    "text": "Interesting Book to dive deeper\n\nThomas, D., & Hunt, A. (2019). The pragmatic programmer, 20th anniversary edition: Journey to mastery (Second edition). Addison-Wesley.\n\n\n\n\n\n\n\n\nTip\n\n\nA fantastic textbook to understand the principles of modern software development and how to create effective software. Also available as a really good audiobook!\n\n\n\n\n\nFor more interesting literature to learn more about Python, take a look at the literature list of this course.\n\n\n\nLecture III - Building Reusable Functions | Programming with Python | Dr. Tobias Vlćek | Home"
  },
  {
    "objectID": "part-03/lecture-functions-presentation.html#multiple-parameters",
    "href": "part-03/lecture-functions-presentation.html#multiple-parameters",
    "title": "Lecture III - Building Reusable Functions",
    "section": "Multiple Parameters",
    "text": "Multiple Parameters\n\nWe can also have multiple parameters in a function definition\nThey are called positional arguments and are separated by commas\nWhen we call them, they must be provided in the same order\nAlternatively, we could call them by name, as for example in this function call print(\"h\",\"i\",sep='')\n\n\n&gt; Question: What will be printed here?\n\ndef call_parameters(parameter_a, parameter_b):\n    print(parameter_a, parameter_b)\n\ncall_parameters(parameter_b=\"Hello\", parameter_a=\"World\")\n\n\n\nWorld Hello"
  },
  {
    "objectID": "part-03/lecture-functions-presentation.html#arbitrary-arguments",
    "href": "part-03/lecture-functions-presentation.html#arbitrary-arguments",
    "title": "Lecture III - Building Reusable Functions",
    "section": "Arbitrary Arguments",
    "text": "Arbitrary Arguments\n\nWe can also use arbitrary arguments to pass a variable number of arguments to a function\nThis is done by using the * sign\nPython provides two special syntaxes for this\n*args and **kwargs."
  },
  {
    "objectID": "part-03/lecture-functions-presentation.html#args-arbitrary-positional-arguments",
    "href": "part-03/lecture-functions-presentation.html#args-arbitrary-positional-arguments",
    "title": "Lecture III - Building Reusable Functions",
    "section": "*args (Arbitrary Positional Arguments)",
    "text": "*args (Arbitrary Positional Arguments)\n\n*args allows a function to accept any number of positional arguments\nThe arguments are packed into a tuple inside the function\n\n\ndef print_args(*args):\n    for arg in args:\n        print(arg)\n\nprint_args(\"Hello\", \"World\", \"This\", \"is\", \"Python\")\n\n\n\nHello\nWorld\nThis\nis\nPython"
  },
  {
    "objectID": "part-03/lecture-functions-presentation.html#kwargs-arbitrary-keyword-arguments",
    "href": "part-03/lecture-functions-presentation.html#kwargs-arbitrary-keyword-arguments",
    "title": "Lecture III - Building Reusable Functions",
    "section": "**kwargs (Arbitrary Keyword Arguments)",
    "text": "**kwargs (Arbitrary Keyword Arguments)\n\n**kwargs allows a function to accept any number of keyword arguments\nThe arguments are packed into a dictionary inside the function\n\n\ndef print_kwargs(**kwargs):\n    for key, value in kwargs.items():\n        print(f\"{key}: {value}\")\n\nprint_kwargs(name=\"John\", age=25, city=\"New York\")\n\n\n\nname: John\nage: 25\ncity: New York"
  },
  {
    "objectID": "part-03/lecture-functions-presentation.html#combining-args-and-kwargs",
    "href": "part-03/lecture-functions-presentation.html#combining-args-and-kwargs",
    "title": "Lecture III - Building Reusable Functions",
    "section": "Combining *args and **kwargs",
    "text": "Combining *args and **kwargs\n\nWe can also combine *args and **kwargs in a function definition\nThis allows a function to accept any number of positional and keyword arguments\n\n\ndef print_args_kwargs(*args, **kwargs):\n    print(\"Positional arguments:\")\n    for arg in args:\n        print(arg)\n    print(\"\\nKeyword arguments:\")\n    for key, value in kwargs.items():\n        print(f\"{key}: {value}\")\n\nprint_args_kwargs(1, 2, 3, name=\"John\", age=25, city=\"New York\")  \n\n\n\nPositional arguments:\n1\n2\n3\n\nKeyword arguments:\nname: John\nage: 25\ncity: New York"
  },
  {
    "objectID": "part-04/lecture-dimensions-presentation.html#arbitrary-arguments",
    "href": "part-04/lecture-dimensions-presentation.html#arbitrary-arguments",
    "title": "Lecture IV - Handling Data in more than one Dimension",
    "section": "Arbitrary Arguments",
    "text": "Arbitrary Arguments\n\nBack to functions from last lecture as we know more\nWe can also use arbitrary arguments to pass a variable number of arguments to a function\nThis is done by using the * sign\nPython provides two special syntaxes for this\n*args and **kwargs."
  },
  {
    "objectID": "part-04/lecture-dimensions-presentation.html#args-arbitrary-positional-arguments",
    "href": "part-04/lecture-dimensions-presentation.html#args-arbitrary-positional-arguments",
    "title": "Lecture IV - Handling Data in more than one Dimension",
    "section": "*args (Arbitrary Positional Arguments)",
    "text": "*args (Arbitrary Positional Arguments)\n\n*args allows a function to accept any number of positional arguments\nThe arguments are packed into a tuple inside the function\n\n\ndef print_args(*args):\n    for arg in args:\n        print(arg)\n\nprint_args(\"Hello\", \"World\", \"This\", \"is\", \"Python\")\n\n\n\nHello\nWorld\nThis\nis\nPython"
  },
  {
    "objectID": "part-04/lecture-dimensions-presentation.html#kwargs-arbitrary-keyword-arguments",
    "href": "part-04/lecture-dimensions-presentation.html#kwargs-arbitrary-keyword-arguments",
    "title": "Lecture IV - Handling Data in more than one Dimension",
    "section": "**kwargs (Arbitrary Keyword Arguments)",
    "text": "**kwargs (Arbitrary Keyword Arguments)\n\n**kwargs allows a function to accept any number of keyword arguments\nThe arguments are packed into a dictionary inside the function\n\n\ndef print_kwargs(**kwargs):\n    for key, value in kwargs.items():\n        print(f\"{key}: {value}\")\n\nprint_kwargs(name=\"John\", age=25, city=\"New York\")\n\n\n\nname: John\nage: 25\ncity: New York"
  },
  {
    "objectID": "part-04/lecture-dimensions-presentation.html#combining-args-and-kwargs",
    "href": "part-04/lecture-dimensions-presentation.html#combining-args-and-kwargs",
    "title": "Lecture IV - Handling Data in more than one Dimension",
    "section": "Combining *args and **kwargs",
    "text": "Combining *args and **kwargs\n\nWe can also combine *args and **kwargs in a function definition\nThis allows a function to accept any number of positional and keyword arguments\n\n\ndef print_args_kwargs(*args, **kwargs):\n    print(\"Positional arguments:\")\n    for arg in args:\n        print(arg)\n    print(\"\\nKeyword arguments:\")\n    for key, value in kwargs.items():\n        print(f\"{key}: {value}\")\n\nprint_args_kwargs(1, 2, 3, name=\"John\", age=25, city=\"New York\")  \n\n\n\nPositional arguments:\n1\n2\n3\n\nKeyword arguments:\nname: John\nage: 25\ncity: New York"
  },
  {
    "objectID": "part-04/lecture-dimensions-presentation.html#functions",
    "href": "part-04/lecture-dimensions-presentation.html#functions",
    "title": "Lecture IV - Handling Data in more than one Dimension",
    "section": "Functions",
    "text": "Functions\n\nFunctions are reusable blocks of code that perform specific tasks\nThey can accept inputs (parameters) and return outputs\ndef followed by the function name, parameters and a colon\nHelp in organizing code and reducing repetition\n\n\n\ndef greet(name):\n    return f\"Welcome to this lecture, {name}!\"\n\nprint(greet(\"Students\"))\n\n\n\nWelcome to this lecture, Students!"
  },
  {
    "objectID": "part-04/lecture-dimensions-presentation.html#scope",
    "href": "part-04/lecture-dimensions-presentation.html#scope",
    "title": "Lecture IV - Handling Data in more than one Dimension",
    "section": "Scope",
    "text": "Scope\n\nScope determines the visibility and lifetime of variables\nVariables defined inside a function are local to that function\nVariables defined outside of all functions are global\nThey can be accessed from anywhere in the program\n\n\n\ndef greet(name):\n    greeting = f\"Welcome to this lecture, {name}!\"\n    return greeting\n\nprint(greeting) # This will cause an error\n\n&gt;Question: Why does this cause an error?"
  },
  {
    "objectID": "part-04/lecture-dimensions-presentation.html#classes",
    "href": "part-04/lecture-dimensions-presentation.html#classes",
    "title": "Lecture IV - Handling Data in more than one Dimension",
    "section": "Classes",
    "text": "Classes\n\nClasses are blueprints for creating objects\nThey encapsulate data (attributes) and behavior (methods)\nHelp in organizing code and creating objects with similar structures\n\n\n\nclass Lectures:  \n    def __init__(self, name, length_minutes):\n        self.name = name\n        self.length = length_minutes\n\n    def duration(self):\n        return f\"Lecture '{self.name}' is {self.length} minutes long!\"\n\nlecture_4 = Lectures(\"4. Data in more than one dimension\", 90)\nprint(lecture_4.duration())\n\n\n\nLecture '4. Data in more than one dimension' is 90 minutes long!"
  },
  {
    "objectID": "part-04/lecture-dimensions-presentation.html#what-are-tuples",
    "href": "part-04/lecture-dimensions-presentation.html#what-are-tuples",
    "title": "Lecture IV - Handling Data in more than one Dimension",
    "section": "What are Tuples?",
    "text": "What are Tuples?\n\nTuples are ordered collections of items\nThey are immutable (cannot be changed after creation)\nHelp in storing multiple items in a single variable\nCreated using the tuple() function or the () syntax\n\n\n\nmy_tuple = (1, 2, 3, 4, 5)\nprint(my_tuple)\n\n\n\n(1, 2, 3, 4, 5)"
  },
  {
    "objectID": "part-04/lecture-dimensions-presentation.html#tuple-operations",
    "href": "part-04/lecture-dimensions-presentation.html#tuple-operations",
    "title": "Lecture IV - Handling Data in more than one Dimension",
    "section": "Tuple Operations",
    "text": "Tuple Operations\n\nTuples support the same operations as strings\nWe can use indexing and slicing to access elements\nWe can use the + operator to concatenate tuples\nWe can use the * operator to repeat a tuple\n\n\n&gt;Question: What will the following code print?\n\nmy_tuple = (1, 2, 3)    \nprint(my_tuple[1:3])\nprint(my_tuple + (4, 5, 6))\nprint(my_tuple * 2)\n\n\n\n(2, 3)\n(1, 2, 3, 4, 5, 6)\n(1, 2, 3, 1, 2, 3)"
  },
  {
    "objectID": "part-04/lecture-dimensions-presentation.html#tuple-operations-1",
    "href": "part-04/lecture-dimensions-presentation.html#tuple-operations-1",
    "title": "Lecture IV - Handling Data in more than one Dimension",
    "section": "Tuple Operations",
    "text": "Tuple Operations"
  },
  {
    "objectID": "part-04/lecture-dimensions-presentation.html#tuple-methods",
    "href": "part-04/lecture-dimensions-presentation.html#tuple-methods",
    "title": "Lecture IV - Handling Data in more than one Dimension",
    "section": "Tuple Methods",
    "text": "Tuple Methods\n\nTuples support the following methods:\n\ncount(x): Returns the number of times x appears in the tuple\nindex(x): Returns the index of the first occurrence of x\n\n\n\n&gt;Question: What will this code print?\n\nmy_tuple = (1, 2, 3, 2, 4, 2)\nprint(my_tuple.count(2))\nprint(my_tuple.index(3))\n\n\n\n3\n2"
  },
  {
    "objectID": "part-04/lecture-dimensions-presentation.html#tuple-unpacking",
    "href": "part-04/lecture-dimensions-presentation.html#tuple-unpacking",
    "title": "Lecture IV - Handling Data in more than one Dimension",
    "section": "Tuple Unpacking",
    "text": "Tuple Unpacking\n\nAllows us to assign the elements of a tuple to variables\nThe number of variables must match the number of elements\nUse the * operator to assign the remaining elements to a variable\n\n\n\ndef get_student_info(name, age, city):\n    return name, age, city\nname, *rest = get_student_info(\"Peter\", 25, \"Hamburg\")\nprint(f\"Name: {name}\")\nprint(f\"Other info: {rest}\")\n\n\n\nName: Peter\nOther info: [25, 'Hamburg']\n\n\n\n\n\n\n\n\n\n\nWarning\n\n\nThe output is positional, so we have to be careful with the order of the variables."
  },
  {
    "objectID": "part-04/lecture-dimensions-presentation.html#tuples-from-functions",
    "href": "part-04/lecture-dimensions-presentation.html#tuples-from-functions",
    "title": "Lecture IV - Handling Data in more than one Dimension",
    "section": "Tuples from Functions",
    "text": "Tuples from Functions\n\nFunctions can return tuples\nThis is useful if we want to return multiple values from a function\n\n\n\ndef get_student_info(name, age, city):\n    return name, age, city\n\nstudent_info = get_student_info(\"Peter\", 25, \"Hamburg\")\nprint(student_info)\n\n\n\n('Peter', 25, 'Hamburg')\n\n\n\n\n&gt;Question: How would you access the age from the tuple?"
  },
  {
    "objectID": "part-04/lecture-dimensions-presentation.html#tuple-data-types",
    "href": "part-04/lecture-dimensions-presentation.html#tuple-data-types",
    "title": "Lecture IV - Handling Data in more than one Dimension",
    "section": "Tuple Data Types",
    "text": "Tuple Data Types\n\nTuples can contain elements of different data types\n\n\nmy_tuple = (\"Peter\", 25, \"Hamburg\")\nprint(my_tuple)\n\n\n\n('Peter', 25, 'Hamburg')\n\n\n\n\n# This works as well\nmy_tuple = \"Peter\", 25, \"Hamburg\"\nprint(my_tuple)\n\n\n\n('Peter', 25, 'Hamburg')\n\n\n\n\n\n\n\n\n\n\nNote\n\n\nWe can also create tuples by listing the elements separated by commas."
  },
  {
    "objectID": "part-04/lecture-dimensions-presentation.html#what-are-lists",
    "href": "part-04/lecture-dimensions-presentation.html#what-are-lists",
    "title": "Lecture IV - Handling Data in more than one Dimension",
    "section": "What are Lists?",
    "text": "What are Lists?\n\nLists are ordered collections of items\nThey are mutable (can be changed after creation)\nCreated using the list() function or the [] syntax\nThey support the same operations as strings and tuples\nHave much more methods and are more versatile than tuples\n\n\n\nmy_list = [1, 2, 3, 4, 5]\nprint(my_list)\n\n\n\n[1, 2, 3, 4, 5]\n\n\n\n\n&gt;Question: Any idea why lists support more methods?"
  },
  {
    "objectID": "part-04/lecture-dimensions-presentation.html#list-operations",
    "href": "part-04/lecture-dimensions-presentation.html#list-operations",
    "title": "Lecture IV - Handling Data in more than one Dimension",
    "section": "List Operations",
    "text": "List Operations\n\nLists support the same operations as strings\nWe can use indexing and slicing to access elements\nWe can use the + operator to concatenate lists\nWe can use the * operator to repeat a list"
  },
  {
    "objectID": "part-04/lecture-dimensions-presentation.html#list-methods",
    "href": "part-04/lecture-dimensions-presentation.html#list-methods",
    "title": "Lecture IV - Handling Data in more than one Dimension",
    "section": "List Methods",
    "text": "List Methods\n\nCommon methods for lists:\n\ncount(x): Returns the number of times x appears in the list\nappend(x): Adds an element x to the end of the list\ninsert(i, x): Inserts an element x at index i\nremove(x): Removes the first occurrence of element x\nindex(x): Returns the index of the first occurrence of x\n\npop([i]): Removes the element at index i and returns it\nsort(): Sorts the list in ascending order\nreverse(): Reverses the list"
  },
  {
    "objectID": "part-04/lecture-dimensions-presentation.html#list-comprehensions",
    "href": "part-04/lecture-dimensions-presentation.html#list-comprehensions",
    "title": "Lecture IV - Handling Data in more than one Dimension",
    "section": "List Comprehensions",
    "text": "List Comprehensions\n\nList comprehensions provide a concise way to create lists\nSyntax: [expression for item in iterable if condition]"
  },
  {
    "objectID": "part-04/lecture-dimensions-presentation.html#what-are-sets",
    "href": "part-04/lecture-dimensions-presentation.html#what-are-sets",
    "title": "Lecture IV - Handling Data in more than one Dimension",
    "section": "What are Sets?",
    "text": "What are Sets?\n\nSets are unordered collections of unique elements\nThey are mutable (can be changed after creation)\nCreated using the set() function or the {} syntax\nSupports + and * operations like lists and tuples\nUnlike lists and tuples, sets do not support indexing\n\n\n\nmy_set = {1, 2, 2, 5, 5}\nprint(my_set)\n\n\n\n{1, 2, 5}"
  },
  {
    "objectID": "part-04/lecture-dimensions-presentation.html#set-operations",
    "href": "part-04/lecture-dimensions-presentation.html#set-operations",
    "title": "Lecture IV - Handling Data in more than one Dimension",
    "section": "Set Operations",
    "text": "Set Operations\n\nSets support the same operations as strings\nWe can use indexing and slicing to access elements\nWe can use the + operator to concatenate sets\nWe can use the * operator to repeat a set"
  },
  {
    "objectID": "part-04/lecture-dimensions-presentation.html#set-methods",
    "href": "part-04/lecture-dimensions-presentation.html#set-methods",
    "title": "Lecture IV - Handling Data in more than one Dimension",
    "section": "Set Methods",
    "text": "Set Methods\n\nCommon methods for sets:\n\nadd(x): Adds an element x to the set\nremove(x): Removes an element x from the set\ndiscard(x): Removes an element x from the set if it is present\npop(): Removes and returns an arbitrary element from the set\nupdate(other): Adds all elements from other to the set"
  },
  {
    "objectID": "part-04/lecture-dimensions-presentation.html#set-comprehensions",
    "href": "part-04/lecture-dimensions-presentation.html#set-comprehensions",
    "title": "Lecture IV - Handling Data in more than one Dimension",
    "section": "Set Comprehensions",
    "text": "Set Comprehensions\n\nSet comprehensions provide a concise way to create sets\nSyntax: {expression for item in iterable if condition}\n\n\nmy_set = {x for x in range(10)} \nprint(my_set)\n\n\n\n{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}"
  },
  {
    "objectID": "part-04/lecture-dimensions-presentation.html#when-to-use-which",
    "href": "part-04/lecture-dimensions-presentation.html#when-to-use-which",
    "title": "Lecture IV - Handling Data in more than one Dimension",
    "section": "When to use which?",
    "text": "When to use which?\n\nTuples: store a collection of items that should not be changed\nLists: store a collection of items that should be changed\nSets: store a collection of items that should not be changed and duplicates are not allowed\nDictionaries: store a collection of items that should be changed, duplicates are not allowed and require key-value pairs\n\n\n\n\n\n\n\n\nTip\n\n\nYou can convert between the data types using tuple(), list(), set() and dict(). Note, that this is not always possible, e.g. you cannot convert a list to a dictionary without specifying a key."
  },
  {
    "objectID": "part-04/lecture-dimensions-presentation.html#what-are-dictionaries",
    "href": "part-04/lecture-dimensions-presentation.html#what-are-dictionaries",
    "title": "Lecture IV - Handling Data in more than one Dimension",
    "section": "What are Dictionaries?",
    "text": "What are Dictionaries?\n\nDictionaries are unordered collections of key-value pairs\nThey are mutable (can be changed after creation)\nKeys must be unique and immutable\nValues can be of any type\nCreated using the dict() function or the {} syntax\nAs sets we cannot access them by index\n\n\n\nwho_am_i = {\"name\": \"Tobias\", \"age\": 30, \"city\": \"Hamburg\"}\nprint(who_am_i)\n\n\n\n{'name': 'Tobias', 'age': 30, 'city': 'Hamburg'}"
  },
  {
    "objectID": "part-04/lecture-dimensions-presentation.html#dictionary-operations",
    "href": "part-04/lecture-dimensions-presentation.html#dictionary-operations",
    "title": "Lecture IV - Handling Data in more than one Dimension",
    "section": "Dictionary Operations",
    "text": "Dictionary Operations\n\nCommon operations and methods:\nin operation to check if a key is in the dictionary\nfor loop to iterate over the dictionary\nkeys() method to return a view of the dictionary’s keys\nvalues() method to return a view of the dictionary’s values\npop(key[, default]) to remove a key and return its value"
  },
  {
    "objectID": "part-04/lecture-dimensions-presentation.html#dictionary-comprehensions",
    "href": "part-04/lecture-dimensions-presentation.html#dictionary-comprehensions",
    "title": "Lecture IV - Handling Data in more than one Dimension",
    "section": "Dictionary Comprehensions",
    "text": "Dictionary Comprehensions\n\nDictionary comprehensions provide a concise way to create dictionaries\nSyntax: {key_expression: value_expression for item in iterable if condition}"
  },
  {
    "objectID": "part-04/lecture-dimensions-presentation.html#inputoutput",
    "href": "part-04/lecture-dimensions-presentation.html#inputoutput",
    "title": "Lecture IV - Handling Data in more than one Dimension",
    "section": "Input/Output",
    "text": "Input/Output\n\nA common task in programming is to interact with users\nRemember the input() function from the first lecture?\nIt is a classical example of user input\nAn example of output is the print() function\n\n\n\nname = input(\"Please enter your name: \")    \nprint(f\"Hello, {name}!\")\n\n\n\n\n\n\n\n\n\nNote\n\n\nThus, we have already worked with I/O in Python!"
  },
  {
    "objectID": "part-04/lecture-dimensions-presentation.html#reading-and-writing-files",
    "href": "part-04/lecture-dimensions-presentation.html#reading-and-writing-files",
    "title": "Lecture IV - Handling Data in more than one Dimension",
    "section": "Reading and Writing Files",
    "text": "Reading and Writing Files\n\nWe also need to interact with data\nFile handling in Python is quite simple:\n\nUse open(file_name, mode) to open a file\nModes: \"r\" (read), \"w\" (write), \"a\" (append)\n\nBasic operations:\n\nRead: file.read()\nWrite: file.write(content)\nClose: file.close()"
  },
  {
    "objectID": "part-04/lecture-dimensions-presentation.html#working-with-other-file-types",
    "href": "part-04/lecture-dimensions-presentation.html#working-with-other-file-types",
    "title": "Lecture IV - Handling Data in more than one Dimension",
    "section": "Working with other file types",
    "text": "Working with other file types\n\nNaturally, we also want to work with other file types!\nReading and writing CSV files is a common tasks in data analysis\nExcel files are used in many applications and companies\nWe will see how to do this later in the course\n\n\n\n\n\n\n\n\nNote\n\n\nAnd that’s it for todays lecture!\nWe now have covered the basics of tuples, sets, lists and dictionaries as well as some basic file handling. For now, just remember that advanced reading and writing is possible and that there are libraries that help with this.\n\n\n\nLiterature {.title}"
  },
  {
    "objectID": "part-04/lecture-dimensions-presentation.html#file-handling-in-action",
    "href": "part-04/lecture-dimensions-presentation.html#file-handling-in-action",
    "title": "Lecture IV - Handling Data in more than one Dimension",
    "section": "File Handling in Action",
    "text": "File Handling in Action\n\nfile = open(\"hi.txt\", \"w\") # This creates a file called \"hi.txt\"\nfile.write(\"Hello, World!\") # This writes \"Hello, World!\" to the file\nfile.close() # This closes the file\nprint(\"File successfully written\")\n\n\n\nFile successfully written\n\n\n\n&gt;Question: Any ideas how to read the file?\n\n\n\nfile = open(\"hi.txt\", \"r\") # This opens the file \"hi.txt\"\ncontent = file.read() # This reads the content of the file\nfile.close() # This closes the file\nprint(content) # This prints the content of the file\n\n\n\nHello, World!\n\n\n\n\n\n\n\n\n\n\nTip\n\n\nClose files with file.close() to free up system resources and ensure data is properly saved."
  },
  {
    "objectID": "part-04/lecture-dimensions-presentation.html#easy-file-handling-with-with",
    "href": "part-04/lecture-dimensions-presentation.html#easy-file-handling-with-with",
    "title": "Lecture IV - Handling Data in more than one Dimension",
    "section": "Easy File Handling with with",
    "text": "Easy File Handling with with\n\nWe can use the with statement to open a file\nThis ensures the file is properly closed after its handling finishes\nIt’s a good practice to use it\n\n\nwith open(\"hi_again.txt\", \"w\") as file:\n    file.write(\"Hello again, World!\")\nprint(\"File successfully written\")\n\n\n\nFile successfully written\n\n\n\n#| eval: true #| output-location: fragment\nwith open(“hi_again.txt”, “r”) as file: content = file.read() print(content) ## Working with other file types\n\nNaturally, we also want to work with other file types!\nReading and writing CSV files is a common tasks in data analysis\nExcel files are used in many applications and companies\nWe will see how to do this later in the course\n\n\n\n\n\n\n\n\n\nTip\n\n\nFor now, just remember that this is possible and that there are libraries that help with this\n\n\n\n\n\n\nLecture IV - Handling Data in more than one Dimension | Programming with Python | Dr. Tobias Vlćek | Home"
  },
  {
    "objectID": "part-04/lecture-dimensions-presentation.html#easier-file-handling-with-with",
    "href": "part-04/lecture-dimensions-presentation.html#easier-file-handling-with-with",
    "title": "Lecture IV - Handling Data in more than one Dimension",
    "section": "Easier File Handling with with",
    "text": "Easier File Handling with with\n\nWe can also use the with statement to open a file\nThis ensures the file is properly closed after its handling finishes\nIt’s a good practice to use it when working with files\n\n\nwith open(\"hi_again.txt\", \"w\") as file:\n    file.write(\"Hello again, World!\")\n\nprint(\"File successfully written\")\n\n\n\nFile successfully written\n\n\n\n&gt;Task: Open the file hi_again.txt and print its content using with"
  },
  {
    "objectID": "part-04/lecture-dimensions-presentation.html#comprehensions",
    "href": "part-04/lecture-dimensions-presentation.html#comprehensions",
    "title": "Lecture IV - Handling Data in more than one Dimension",
    "section": "Comprehensions",
    "text": "Comprehensions\n\nComprehensions provide a concise way to create data structures\n\nTuple comprehensions: (x for x in iterable)\nList comprehensions: [x for x in iterable]\nSet comprehensions: {x for x in iterable}\nDictionary comprehensions: {x: y for x, y in iterable}\n\n\n\n\n\n\n\n\n\nTip\n\n\nThe iterable can be any object that can be iterated over, e.g. a list, tuple, set, dictionary, etc."
  },
  {
    "objectID": "part-04/lecture-dimensions-presentation.html#lists-in-action",
    "href": "part-04/lecture-dimensions-presentation.html#lists-in-action",
    "title": "Lecture IV - Handling Data in more than one Dimension",
    "section": "Lists in Action",
    "text": "Lists in Action\n&gt;Task: Solve the following problem using lists:\n\n# Imagine the following shoppping list for this weekend\nshopping_list = [\"cider\", \"beer\", \"bread\", \"frozen_pizza\"]\n\n\n\nFirst, add some apples to the list for a healthy option\nNext, remove the cider as you already have some at home\nSort all items in the list alphabetically\nPrint each item of the list on a new line\n\n\n\n\n\n\n\n\n\nTip\n\n\nYou can use the methods and loops we learned so far to solve the problem."
  },
  {
    "objectID": "part-04/lecture-dimensions-presentation.html#sets-in-action",
    "href": "part-04/lecture-dimensions-presentation.html#sets-in-action",
    "title": "Lecture IV - Handling Data in more than one Dimension",
    "section": "Sets in Action",
    "text": "Sets in Action\n&gt;Task: Solve the following problem using sets:\n\n# You have a list of friends from two different groups\nfriends_group_1 = [\"Neo\", \"Morpheus\", \"Trinity\", \"Cypher\"]\nfriends_group_2 = [ \"Smith\", \"Apoc\", \"Cypher\", \"Morpheus\"]\n\n\n\nFirst, find the mutual friends in both groups\nThen create a new set of all friends from both groups\nCount the number of friends in total\nPrint each item of the set on a new line\n\n\n\n\n\n\n\n\n\nTip\n\n\nNotice that we can partly use the same procedure as we used for lists."
  },
  {
    "objectID": "part-04/lecture-dimensions-presentation.html#speed-differences",
    "href": "part-04/lecture-dimensions-presentation.html#speed-differences",
    "title": "Lecture IV - Handling Data in more than one Dimension",
    "section": "Speed Differences",
    "text": "Speed Differences\n\nLists are the most versatile, but slowest\nTuples are generally faster than lists\nSets are generally faster than lists and tuples\nDictionaries depend, but are generally faster than lists and tuples\n\n\n\nCode\nimport timeit\n\n# Number of elements in each data structure\nn = 10000000\n\n# Setup for each data structure, including the test function\nsetup_template = \"\"\"\ndef test_membership(data_structure, element):\n    return element in data_structure\ndata = {data_structure}\n\"\"\"\n\nsetups = {\n    'Tuple': setup_template.format(data_structure=f\"tuple(range({n}))\"),\n    'List': setup_template.format(data_structure=f\"list(range({n}))\"),\n    'Set': setup_template.format(data_structure=f\"set(range({n}))\"),\n    'Dictionary': setup_template.format(data_structure=f\"{{i: i for i in range({n})}}\")\n}\n\n# Measure time for each data structure\nprint(f\"Time taken for a single membership test in {n} elements (in seconds):\")\nprint(\"-\" * 75)\nfor name, setup in setups.items():\n    stmt = f\"test_membership(data, {n-1})\"  # Test membership of the last element\n    time_taken = timeit.timeit(stmt, setup=setup, number=1)\n    print(f\"{name:&lt;10}: {time_taken:.8f}\")\nprint(\"-\" * 75)\nprint(\"Note, that theses values are machine dependent and just for illustration!\")\n\n\n\n\nTime taken for a single membership test in 10000000 elements (in seconds):\n---------------------------------------------------------------------------\nTuple     : 0.05322033\nList      : 0.06057096\nSet       : 0.00000254\nDictionary: 0.00000338\n---------------------------------------------------------------------------\nNote, that theses values are machine dependent and just for illustration!"
  },
  {
    "objectID": "part-04/lecture-dimensions-presentation.html#interesting-books",
    "href": "part-04/lecture-dimensions-presentation.html#interesting-books",
    "title": "Lecture IV - Handling Data in more than one Dimension",
    "section": "Interesting Books",
    "text": "Interesting Books\n\nDowney, A. B. (2024). Think Python: How to think like a computer scientist (Third edition). O’Reilly. Link to free online version\nElter, S. (2021). Schrödinger programmiert Python: Das etwas andere Fachbuch (1. Auflage). Rheinwerk Verlag.\n\n\n\n\n\n\n\n\nTip\n\n\nNothing new here, but these are still great books!\n\n\n\n\n\nFor more interesting literature to learn more about Python, take a look at the literature list of this course.\n\n\n\nLecture IV - Handling Data in more than one Dimension | Programming with Python | Dr. Tobias Vlćek | Home"
  },
  {
    "objectID": "part-04/lecture-dimensions-presentation.html#set-theory",
    "href": "part-04/lecture-dimensions-presentation.html#set-theory",
    "title": "Lecture IV - Handling Data in more than one Dimension",
    "section": "Set Theory",
    "text": "Set Theory\n\nAdditional methods are derived from set theory\n\nunion(other): New set with elements from both sets\nintersection(other): New set with common elements\nisdisjoint(other): True if no elements in common\nissubset(other): True if subset of other\n\n\n\n\n\n\n\n\n\nTip\n\n\nThere are more methods for sets! If you are working intensively with sets, keep that in mind."
  },
  {
    "objectID": "part-04/lecture-dimensions-presentation.html#key-value-pairs",
    "href": "part-04/lecture-dimensions-presentation.html#key-value-pairs",
    "title": "Lecture IV - Handling Data in more than one Dimension",
    "section": "Key-Value Pairs",
    "text": "Key-Value Pairs\n\nWe can access them by their keys, though!\nYou can think of them as a set of key-value pairs\n\n\n\nwho_am_i = {\"name\": \"Tobias\", \"age\": 30, \"city\": \"Hamburg\"}\nprint(who_am_i[\"name\"])\n\n\n\nTobias\n\n\n\n\n\n\n\n\n\n\nNote\n\n\nNote, how we can use the [] operator to access the value of a key?"
  },
  {
    "objectID": "part-04/lecture-dimensions-presentation.html#dictionaries-in-action",
    "href": "part-04/lecture-dimensions-presentation.html#dictionaries-in-action",
    "title": "Lecture IV - Handling Data in more than one Dimension",
    "section": "Dictionaries in Action",
    "text": "Dictionaries in Action\n&gt;Task: Solve the following problem using dictionaries:\n\n# Create a dictionary with the following information about yourself: name, age, city\ni_am = {}\n\n\n\nAdd your favorite color and food to the dictionary\nRemove the city from the dictionary\nPrint your name and age in a formatted sentence"
  },
  {
    "objectID": "part-04/lecture-dimensions-presentation.html#comparison-between-data-types",
    "href": "part-04/lecture-dimensions-presentation.html#comparison-between-data-types",
    "title": "Lecture IV - Handling Data in more than one Dimension",
    "section": "Comparison between Data Types",
    "text": "Comparison between Data Types\n\nTuple: Immutable, ordered, duplicates allowed\nList: Mutable, ordered, duplicates allowed\nSet: Mutable, unordered, no duplicates\nDictionary: Mutable, unordered, no duplicates, key-value pairs\n\n\n\n\n\n\n\n\nTip\n\n\nThis impacts your code, the operations you can perform and the speed of your program. Thus, it makes sense to understand the differences and choose the right data type for the task."
  },
  {
    "objectID": "part-04/lecture-dimensions-presentation.html#illustration-of-speed",
    "href": "part-04/lecture-dimensions-presentation.html#illustration-of-speed",
    "title": "Lecture IV - Handling Data in more than one Dimension",
    "section": "Illustration of Speed",
    "text": "Illustration of Speed\n\n\nCode\nimport timeit\n\ndef test_membership(data_structure, element):\n    return element in data_structure\n\n# Number of elements in each data structure\nn = 10000\n\n# Number of times to run each test\ntest_runs = 100000\n\n# Setup for each data structure\nsetups = {\n    'Tuple': f\"data = tuple(range({n}))\",\n    'List': f\"data = list(range({n}))\",\n    'Set': f\"data = set(range({n}))\",\n    'Dictionary': f\"data = {{i: i for i in range({n})}}\"\n}\n\n# Measure time for each data structure\ntimes = {}\nfor name, setup in setups.items():\n    stmt = f\"test_membership(data, {n-1})\"  # Test membership of the last element\n    time_taken = timeit.timeit(stmt, setup=f\"{setup}\\nfrom __main__ import test_membership\", number=test_runs)\n    times[name] = time_taken\n\n# Find the slowest time for normalization\nslowest_time = max(times.values())\n\n# Calculate and print relative speeds\nprint(f\"Relative speeds (lower is faster, 1.0 is slowest):\")\nprint(\"-\" * 50)\nfor name, time in times.items():\n    relative_speed = time / slowest_time\n    print(f\"{name:&lt;10}: {relative_speed:.3f}\")\n\n\n\n\nRelative speeds (lower is faster, 1.0 is slowest):\n--------------------------------------------------\nTuple     : 0.891\nList      : 1.000\nSet       : 0.001\nDictionary: 0.001"
  },
  {
    "objectID": "part-04/lecture-dimensions-presentation.html#iterables",
    "href": "part-04/lecture-dimensions-presentation.html#iterables",
    "title": "Lecture IV - Handling Data in more than one Dimension",
    "section": "Iterables",
    "text": "Iterables\n\nWe have already introduced those!\nWe can use the for loop to iterate over an iterable\n\n\n\nshopping_list = [\"cider\", \"beer\", \"bread\", \"frozen_pizza\"]\nfor item in shopping_list:\n    print(item)\n\n\n\ncider\nbeer\nbread\nfrozen_pizza\n\n\n\n\n\nwho_am_i = {\"name\": \"Tobias\", \"age\": 30, \"city\": \"Hamburg\"}\nfor key, value in who_am_i.items():\n    print(f\"{key}: {value}\")\n\n\n\nname: Tobias\nage: 30\ncity: Hamburg"
  },
  {
    "objectID": "part-05/lecture-errors-presentation.html#data-structures",
    "href": "part-05/lecture-errors-presentation.html#data-structures",
    "title": "Lecture V - Handling Errors",
    "section": "Data Structures",
    "text": "Data Structures\n\nNewly introduced data structures:\n\nTuples: Ordered, immutable collections\nLists: Ordered, mutable collections\nSets: Unordered collections of unique elements\nDictionaries: Key-value pairs\n\n\n\n\nlist_example = [1, 2, 3, 4, 5]\nset_example = {1, 2, 3, 4, 5}\ndict_example = {\"a\": 1, \"b\": 2, \"c\": 3}\ntuple_example = (1, 2, 3, 4, 5)"
  },
  {
    "objectID": "part-05/lecture-errors-presentation.html#operations-and-methods",
    "href": "part-05/lecture-errors-presentation.html#operations-and-methods",
    "title": "Lecture V - Handling Errors",
    "section": "Operations and Methods",
    "text": "Operations and Methods\n\nEach data structure has specific operations and methods:\n\nTuples and Lists: Indexing, slicing, concatenation\nSets: Union, intersection, difference\nDictionaries: Key-based access, keys(), values()\n\n\n\n\n\n\n\n\n\nTip\n\n\nComprehensions for concise creation of these structures are often used in practice to create new data structures from existing ones."
  },
  {
    "objectID": "part-05/lecture-errors-presentation.html#file-handling",
    "href": "part-05/lecture-errors-presentation.html#file-handling",
    "title": "Lecture V - Handling Errors",
    "section": "File Handling",
    "text": "File Handling\n\nBasic file operations\n\nOpening files with open()\nReading and writing files\nUsing the with statement for safer file handling"
  },
  {
    "objectID": "part-05/lecture-errors-presentation.html#performance-considerations",
    "href": "part-05/lecture-errors-presentation.html#performance-considerations",
    "title": "Lecture V - Handling Errors",
    "section": "Performance Considerations",
    "text": "Performance Considerations\n\nWe discussed the performance differences between these data structures:\n\nLists are versatile but slower for certain operations\nSets and dictionaries offer faster lookup times"
  },
  {
    "objectID": "part-05/lecture-errors-presentation.html#inputoutput-io",
    "href": "part-05/lecture-errors-presentation.html#inputoutput-io",
    "title": "Lecture V - Handling Errors",
    "section": "Input/Output (I/O)",
    "text": "Input/Output (I/O)\n\nRevisited user input with input() function\nExplored file I/O for reading from and writing to files\n\nThis recap covers the main points from our last lecture on data structures and file handling in Python."
  },
  {
    "objectID": "part-05/lecture-errors-presentation.html#io-and-file-handling",
    "href": "part-05/lecture-errors-presentation.html#io-and-file-handling",
    "title": "Lecture V - Handling Errors",
    "section": "I/O and File Handling",
    "text": "I/O and File Handling\n\nBasic file operations\n\nOpening files with open()\nReading and writing files\nUsing the with statement for safer file handling\n\n\n\n\n\n\n\n\n\nNote\n\n\nThis covers the main points from our last lecture on data structures and file handling in Python."
  },
  {
    "objectID": "part-05/lecture-errors-presentation.html#what-are-exceptions",
    "href": "part-05/lecture-errors-presentation.html#what-are-exceptions",
    "title": "Lecture V - Handling Errors",
    "section": "What are Exceptions?",
    "text": "What are Exceptions?\n\nExceptions are discovered errors that occur during the execution\n\n\n\ndef divide_numbers(a, b):\n        result = a / b\n        return result \n\nprint(divide_numbers(10, 0))\nprint(\"I will not be printed as the program crashed before.\")\n\n\n\nZeroDivisionError: division by zero\n\n\n\n\n\n\n\n\nWarning\n\n\nUndiscovered errors can be very hard to debug and can cause crashes and other issues."
  },
  {
    "objectID": "part-05/lecture-errors-presentation.html#try-except-blocks",
    "href": "part-05/lecture-errors-presentation.html#try-except-blocks",
    "title": "Lecture V - Handling Errors",
    "section": "try-except Blocks",
    "text": "try-except Blocks\n\ntry-except blocks are used to handle exceptions\ntry block contains the code that might raise an exception\nexcept block contains the executed code if an exception occurs\n\n\n\ndef divide_numbers(a, b):\n    try:\n        result = a / b\n        return result\n    except ZeroDivisionError:\n        return \"Error: Division by zero is not allowed.\"\n\nprint(divide_numbers(10, 0))\nprint(\"I will be printed as the exception was handled!\")\n\n\n\nError: Division by zero is not allowed.\nI will be printed as the exception was handled!"
  },
  {
    "objectID": "part-05/lecture-errors-presentation.html#common-built-in-exceptions",
    "href": "part-05/lecture-errors-presentation.html#common-built-in-exceptions",
    "title": "Lecture V - Handling Errors",
    "section": "Common Built-in Exceptions",
    "text": "Common Built-in Exceptions\n\nValueError: argument of correct type but inappropriate value\nTypeError: function applied to object of inappropriate type\nNameError: raised when a local or global name is not found\nIndexError: raised when a sequence subscript is out of range\nKeyError: raised when a dictionary key is not found\nFileNotFoundError: file or directory not found\nZeroDivisionError: division or modulo by zero\nAttributeError: attribute reference or assignment fails\nImportError: import of a modulefails\nSyntaxError: parser encounters a syntax error\nIndentationError: indentation is not correct\nRuntimeError: error does not fall into any category"
  },
  {
    "objectID": "part-05/lecture-errors-presentation.html#common-built-in-exceptions-i",
    "href": "part-05/lecture-errors-presentation.html#common-built-in-exceptions-i",
    "title": "Lecture V - Handling Errors",
    "section": "Common Built-in Exceptions I",
    "text": "Common Built-in Exceptions I\n\nValueError: argument of correct type but inappropriate value\nTypeError: function applied to object of inappropriate type\nNameError: raised when a local or global name is not found\nIndexError: raised when a sequence subscript is out of range\nKeyError: raised when a dictionary key is not found\nFileNotFoundError: file or directory not found\nZeroDivisionError: division or modulo by zero"
  },
  {
    "objectID": "part-05/lecture-errors-presentation.html#common-built-in-exceptions-ii",
    "href": "part-05/lecture-errors-presentation.html#common-built-in-exceptions-ii",
    "title": "Lecture V - Handling Errors",
    "section": "Common Built-in Exceptions II",
    "text": "Common Built-in Exceptions II\n\nAttributeError: attribute reference or assignment fails\nImportError: import of a modulefails\nSyntaxError: parser encounters a syntax error\nIndentationError: indentation is not correct\nRuntimeError: error does not fall into any category\n\n\n\n\n\n\n\n\nNote\n\n\nThe list of built-in exceptions is even longer, these are just the most common ones. We won’t cover the errors listed here in detail, but it is good to be aware of them."
  },
  {
    "objectID": "part-05/lecture-errors-presentation.html#raising-exceptions-1",
    "href": "part-05/lecture-errors-presentation.html#raising-exceptions-1",
    "title": "Lecture V - Handling Errors",
    "section": "Raising Exceptions",
    "text": "Raising Exceptions\n\nWe can raise exceptions ourselves using the raise statement\nIt allows us to handle errors in a more controlled manner\n\n\n\ndef validate_age(age):\n    if age &lt; 0:\n        raise ValueError\n    return age\n\nprint(validate_age(25)) # This will print 25\nprint(validate_age(-1)) # This will raise a ValueError\n\n&gt;Task: Try to raise an exception in the function above by passing a string to the validate_age function. What happens?"
  },
  {
    "objectID": "part-05/lecture-errors-presentation.html#raising-exceptions-with-custom-messages",
    "href": "part-05/lecture-errors-presentation.html#raising-exceptions-with-custom-messages",
    "title": "Lecture V - Handling Errors",
    "section": "Raising Exceptions with Custom Messages",
    "text": "Raising Exceptions with Custom Messages\n\nWe can also raise exceptions with custom messages\nThis helps to provide more information about the error\n\n\n\ndef validate_age(age):\n    if age &lt; 0:\n        raise ValueError(\"Age cannot be negative\")\n    return age\n\nprint(validate_age(25)) # This will print 25\nprint(validate_age(-1)) # This will raise a ValueError\n\n\n\n&gt;Question: What do you think the raise statement will show now?"
  },
  {
    "objectID": "part-05/lecture-errors-presentation.html#what-are-assertions",
    "href": "part-05/lecture-errors-presentation.html#what-are-assertions",
    "title": "Lecture V - Handling Errors",
    "section": "What are Assertions?",
    "text": "What are Assertions?\n\nAssertions are statements that check if a condition is true\nIf the condition is false, an AssertionError is raised\nWe could use them to check the results of a calculation\n\n\n\nx = 9\ny = 10\nassert x &lt; y, \"x is not smaller than y\"\nassert isinstance(y, float), \"y is not a float\"\n\n\n\n&gt;Task: Try to run the code above and discuss what happens.\n\n\n\n\n\n\n\n\nNote\n\n\nisinstance is a built-in function that checks if an object is an instance of a class."
  },
  {
    "objectID": "part-05/lecture-errors-presentation.html#assertions-in-functions",
    "href": "part-05/lecture-errors-presentation.html#assertions-in-functions",
    "title": "Lecture V - Handling Errors",
    "section": "Assertions in Functions",
    "text": "Assertions in Functions\n\nWe can also use assertions in functions to check the results of a calculation\n\ndef divide_numbers(a, b): assert b != 0, “Division by zero is not allowed” return a / b\nprint(divide_numbers(10, 0)) # This will raise an AssertionError ```"
  },
  {
    "objectID": "part-05/lecture-errors-presentation.html#what-is-debugging",
    "href": "part-05/lecture-errors-presentation.html#what-is-debugging",
    "title": "Lecture V - Handling Errors",
    "section": "What is Debugging?",
    "text": "What is Debugging?\n\nDebugging is the process of finding and fixing errors in code\nWe can use print and assert statements to debug our code\nWe can also use debugging tools that are built into most IDEs"
  },
  {
    "objectID": "part-05/lecture-errors-presentation.html#using-print-statements",
    "href": "part-05/lecture-errors-presentation.html#using-print-statements",
    "title": "Lecture V - Handling Errors",
    "section": "Using Print Statements",
    "text": "Using Print Statements\n\nWe can use print statements to debug our code\nWe can also use debugging tools that are built into most IDEs"
  },
  {
    "objectID": "part-05/lecture-errors-presentation.html#using-debugging-tools",
    "href": "part-05/lecture-errors-presentation.html#using-debugging-tools",
    "title": "Lecture V - Handling Errors",
    "section": "Using Debugging Tools",
    "text": "Using Debugging Tools\n\nWe can also use debugging tools built into most IDEs\nAllow to step through code, set breakpoints, and inspect variables\nWe will use Thonny, but there are many other options"
  },
  {
    "objectID": "part-05/lecture-errors-presentation.html#using-logging",
    "href": "part-05/lecture-errors-presentation.html#using-logging",
    "title": "Lecture V - Handling Errors",
    "section": "Using Logging",
    "text": "Using Logging\n\nWe can also use logging to track the execution of a program\nIt is a structured way to log errors and other issues\nYou can specify the level of severity for each log message\nHide messages of a certain severity if you want to during execution\n\n\n\n\n\n\n\n\nNote\n\n\nAnd that’s it for todays lecture!\nWe now have covered the basics of errors, exceptions and debugging in Python. Logging is beyond our scope, but it is good to know should you work with larger codebases later on."
  },
  {
    "objectID": "part-05/lecture-errors-presentation.html#what-are-regular-expressions",
    "href": "part-05/lecture-errors-presentation.html#what-are-regular-expressions",
    "title": "Lecture V - Handling Errors",
    "section": "What are Regular Expressions?",
    "text": "What are Regular Expressions?\n\nRegular expressions are a way to search for patterns in text\nThey are a powerful tool for string manipulation\nWe can use the re module to work with regular expressions"
  },
  {
    "objectID": "part-05/lecture-errors-presentation.html#using-regular-expressions",
    "href": "part-05/lecture-errors-presentation.html#using-regular-expressions",
    "title": "Lecture V - Handling Errors",
    "section": "Using Regular Expressions",
    "text": "Using Regular Expressions\n\n\n\nLecture V - Handling Errors | Programming with Python | Dr. Tobias Vlćek | Home"
  },
  {
    "objectID": "part-05/lecture-errors-presentation.html#try-except-blocks-in-action",
    "href": "part-05/lecture-errors-presentation.html#try-except-blocks-in-action",
    "title": "Lecture V - Handling Errors",
    "section": "try-except Blocks in Action",
    "text": "try-except Blocks in Action\n&gt;Grouptask: Solve the following problem using try-except blocks:\n\n\n# Implement a function that converts a string to an integer\n# 1. Try to convert the input_string to an integer\n# 2. If successful, return the integer\n# 3. If a ValueError occurs, catch it and return \"Invalid input: not a number\"\n# 4. If any other exception occurs, catch it and return \n# \"An unexpected error occurred: [type of exception]\"\n\n# Your code here\n\n# Test cases\nprint(string_to_int(\"42\"))        # Should print: 42\nprint(string_to_int(\"Hello\"))     # Should print: Invalid \nprint(string_to_int([123]))       \n\n\n\nQuestion: What is the output of the last line?"
  },
  {
    "objectID": "part-05/lecture-errors-presentation.html#assertions-in-action",
    "href": "part-05/lecture-errors-presentation.html#assertions-in-action",
    "title": "Lecture V - Handling Errors",
    "section": "Assertions in Action",
    "text": "Assertions in Action\n&gt;Grouptask: Solve the following problem using assertions:\n\n# Implement a function that takes a list of integers and returns the sum of the numbers. \n# 1. Use assertions to check if the input is a list \n# 2. Use assertions to check if the list contains only integers.\n# 3. If the list contains only integers, return the sum of the numbers\n\n# Your code here\n\n# Test cases\nprint(sum_of_numbers([1, 2, 3, 4, 5])) # Should print: 15\nprint(sum_of_numbers([1, 2.0, 3, 4, 5])) # Should print: AssertionError"
  },
  {
    "objectID": "part-05/lecture-errors-presentation.html#using-print-and-assert",
    "href": "part-05/lecture-errors-presentation.html#using-print-and-assert",
    "title": "Lecture V - Handling Errors",
    "section": "Using Print and Assert",
    "text": "Using Print and Assert\n\nprint: check the values of variables at different points\nassert: check calculations or the types of variables\n\n\n\nx = \"Hello\" # x is a string\nprint(x)\nx = 42.0 # x is a float\nprint(x)\nassert isinstance(x, float), \"x is not a float\"\nassert x == 42.0, \"x is not 42.0\"\n\n\n\nHello\n42.0\n\n\n\n\n\n\n\n\n\n\nNote\n\n\nWhile this can be useful, it is not always the best way to debug code."
  },
  {
    "objectID": "part-05/lecture-errors-presentation.html#debugging-in-thonny",
    "href": "part-05/lecture-errors-presentation.html#debugging-in-thonny",
    "title": "Lecture V - Handling Errors",
    "section": "Debugging in Thonny",
    "text": "Debugging in Thonny\n\nOpen Thonny and load the following code:\n\n\ndef calculate_average(numbers):\n    total = 0\n    count = 0\n    for num in numbers:\n        total += num\n        count += 1\n    \n    # Deliberate error: division by zero when the list is empty\n    average = total / count\n    return average\n\n# Test cases\ntest_lists = [\n    [1, 2, 3, 4, 5],\n    [10, 20, 30],\n    []  # This will cause an error\n    ]\n    \nfor i, test_list in enumerate(test_lists):\n    print(f\"Test case {i + 1}:\")\n    result = calculate_average(test_list)\n    print(f\"Average: {result}\\n\")\n\n\nClick on the bug icon on the right side of the screen to open the debugging panel\nUse the step over, step into, step out buttons to navigate through your code\nUse the variable viewer to inspect the values of variables at different points in the code\nUse the breakpoints to pause the execution of the code at a specific point"
  },
  {
    "objectID": "part-05/lecture-errors-presentation.html#debugging-in-thonny-i",
    "href": "part-05/lecture-errors-presentation.html#debugging-in-thonny-i",
    "title": "Lecture V - Handling Errors",
    "section": "Debugging in Thonny I",
    "text": "Debugging in Thonny I\n&gt;Task: Open Thonny and copy the following code:\n\ndef calculate_average(numbers):\n    total = 0\n    count = 0\n    for num in numbers:\n        total += num\n        count += 1\n    \n    average = total / count\n    return average\n\n# Test cases\ntest_lists = [\n    [1, 2, 3, 4, 5],\n    [10, 20, 30],\n    []\n    ]\n    \nfor i, test_list in enumerate(test_lists):\n    print(f\"Test case {i + 1}:\")\n    result = calculate_average(test_list)\n    print(f\"Average: {result}\\n\")"
  },
  {
    "objectID": "part-05/lecture-errors-presentation.html#debugging-in-thonny-ii",
    "href": "part-05/lecture-errors-presentation.html#debugging-in-thonny-ii",
    "title": "Lecture V - Handling Errors",
    "section": "Debugging in Thonny II",
    "text": "Debugging in Thonny II\n\nClick on the bug icon on the left side of the screen"
  },
  {
    "objectID": "part-05/lecture-errors-presentation.html#debugging-in-thonny-iii",
    "href": "part-05/lecture-errors-presentation.html#debugging-in-thonny-iii",
    "title": "Lecture V - Handling Errors",
    "section": "Debugging in Thonny III",
    "text": "Debugging in Thonny III\n\nUse step over, step into and step out to navigate through your code\nUse the variable viewer to inspect variables at different points\nUse the breakpoints to pause the execution at a specific point"
  },
  {
    "objectID": "part-05/lecture-errors-presentation.html#debugging-tools",
    "href": "part-05/lecture-errors-presentation.html#debugging-tools",
    "title": "Lecture V - Handling Errors",
    "section": "Debugging Tools",
    "text": "Debugging Tools\n&gt;Task: Run the code and use the debugging tools to find the error.\n\nUse step over, step into and step out to navigate through your code\nUse the variable viewer to inspect variables at different points\nUse the breakpoints to pause the execution at a specific point\n\n\n&gt;Question: What do you think the error is?\n\n\n\n\n\n\n\n\nNote\n\n\nThe enumerate function used in the code is super helpful function that returns a tuple containing the index and the value of the item in the list and it is not the error."
  },
  {
    "objectID": "part-04/lecture-dimensions-presentation.html#nesting",
    "href": "part-04/lecture-dimensions-presentation.html#nesting",
    "title": "Lecture IV - Handling Data in more than one Dimension",
    "section": "Nesting",
    "text": "Nesting\n\nWe can nest data structures within each other\nThis is useful if we want to store more complex data\n\n\n\nnormal_list = [1, 2, 3, 4, 5]\nnested_list = [\"Hello, World!\", normal_list, (1,2)]\n\nprint(nested_list)\nprint(nested_list[2])\n\n\n\n['Hello, World!', [1, 2, 3, 4, 5], (1, 2)]\n(1, 2)\n\n\n\n\n\n\n\n\n\n\nTip\n\n\nYou can also nest lists within lists within lists, etc. We could also use this to build matrices, but we will see a much better way to do this later in the course."
  },
  {
    "objectID": "part-05/lecture-errors-presentation.html#interesting-books",
    "href": "part-05/lecture-errors-presentation.html#interesting-books",
    "title": "Lecture V - Handling Errors",
    "section": "Interesting Books",
    "text": "Interesting Books\n\nDowney, A. B. (2024). Think Python: How to think like a computer scientist (Third edition). O’Reilly. Link to free online version\nElter, S. (2021). Schrödinger programmiert Python: Das etwas andere Fachbuch (1. Auflage). Rheinwerk Verlag.\n\n\n\n\n\n\n\n\nTip\n\n\nNothing new here, but these are still great books!\n\n\n\n\n\nFor more interesting literature to learn more about Python, take a look at the literature list of this course.\n\n\n\nLecture V - Handling Errors | Programming with Python | Dr. Tobias Vlćek | Home"
  },
  {
    "objectID": "part-06/lecture-modules-presentation.html#exceptions-and-error-handling",
    "href": "part-06/lecture-modules-presentation.html#exceptions-and-error-handling",
    "title": "Lecture VI - Using Modules and Random Numbers",
    "section": "Exceptions and Error Handling",
    "text": "Exceptions and Error Handling\n\nExceptions are discovered errors during program execution\nCommon built-in exceptions: ValueError, TypeError, etc.\n\n\n\nx = int(\"Hello, World!\")\n\n\n\n&gt;ValueError: invalid literal for int() with base 10: ‘Hello, World!’"
  },
  {
    "objectID": "part-06/lecture-modules-presentation.html#raising-exceptions",
    "href": "part-06/lecture-modules-presentation.html#raising-exceptions",
    "title": "Lecture VI - Using Modules and Random Numbers",
    "section": "Raising Exceptions",
    "text": "Raising Exceptions\n\nWe can raise exceptions using the raise statement\nAllows for more controlled error handling\nCan include custom error messages\n\n\n\nraise ValueError(\"This is a custom error message\")\n\n\n\n\n\n\n\n\n\nNote\n\n\nThe type if raised exception has to exist or you have to create a custom error type before."
  },
  {
    "objectID": "part-06/lecture-modules-presentation.html#assertions",
    "href": "part-06/lecture-modules-presentation.html#assertions",
    "title": "Lecture VI - Using Modules and Random Numbers",
    "section": "Assertions",
    "text": "Assertions\n\nAssertions check if a condition is true\nIf the condition is false, an AssertionError is raised\nUseful for checking calculations or variable types\n\n\n\nx = -1\nassert x &gt; 0, \"x must be positive\"\n\n\n\nQuestion: Will this raise an AssertionError?"
  },
  {
    "objectID": "part-06/lecture-modules-presentation.html#debugging",
    "href": "part-06/lecture-modules-presentation.html#debugging",
    "title": "Lecture VI - Using Modules and Random Numbers",
    "section": "Debugging",
    "text": "Debugging\n\nDebugging is the process of finding and fixing errors in code\nUsing print and assert statements\nUsing logging\nUsing built-in debugging tools in IDEs\n\n\n\n\n\n\n\n\nTip\n\n\nThat’s why IDEs are so helpful in coding."
  },
  {
    "objectID": "part-06/lecture-modules-presentation.html#working-with-csv-files",
    "href": "part-06/lecture-modules-presentation.html#working-with-csv-files",
    "title": "Lecture VI - Using Modules and Random Numbers",
    "section": "Working with CSV Files",
    "text": "Working with CSV Files\n\nCSV (Comma-Separated Values) files are a common format for storing tabular data\nUse the csv module to read and write CSV files\nBasic operations:\n\nRead: csv.reader(file)\nWrite: csv.writer(file)\n\nExample:\nCSV (Comma-Separated Values) files are a common format for storing tabular data"
  },
  {
    "objectID": "part-06/lecture-modules-presentation.html#working-with-excel-files",
    "href": "part-06/lecture-modules-presentation.html#working-with-excel-files",
    "title": "Lecture VI - Using Modules and Random Numbers",
    "section": "Working with Excel Files",
    "text": "Working with Excel Files\n\nExcel files are a common format for storing tabular data\nUse the pandas library to read and write Excel files\nBasic operations:\n\nRead: pandas.read_excel(file_name)\nWrite: pandas.write_excel(file_name, data)"
  },
  {
    "objectID": "part-06/lecture-modules-presentation.html#what-are-regular-expressions",
    "href": "part-06/lecture-modules-presentation.html#what-are-regular-expressions",
    "title": "Lecture VI - Using Modules and Random Numbers",
    "section": "What are Regular Expressions?",
    "text": "What are Regular Expressions?\n\nRegular expressions are a way to search for patterns in text\nThey are a powerful tool for string manipulation\nWe can use the re module to work with regular expressions"
  },
  {
    "objectID": "part-06/lecture-modules-presentation.html#using-regular-expressions",
    "href": "part-06/lecture-modules-presentation.html#using-regular-expressions",
    "title": "Lecture VI - Using Modules and Random Numbers",
    "section": "Using Regular Expressions",
    "text": "Using Regular Expressions\n\n\n\nLecture VI - Using Modules and Random Numbers | Programming with Python | Dr. Tobias Vlćek | Home"
  },
  {
    "objectID": "part-06/lecture-modules-presentation.html#try-except-blocks",
    "href": "part-06/lecture-modules-presentation.html#try-except-blocks",
    "title": "Lecture VI - Using Modules and Random Numbers",
    "section": "Try-Except Blocks",
    "text": "Try-Except Blocks\n\ntry-except blocks are used to handle exceptions\ntry block contains code that might raise an exception\nexcept block contains code executed if an exception occurs\n\n\ntry:\n    # Code that might raise an exception\n    # ...\nexcept ExceptionType as e:\n    # Code to handle the exception\n    # ...\nexcept:\n    # Code to handle any other exceptions\n    # ..."
  },
  {
    "objectID": "part-05/lecture-errors-presentation.html#try-except-blocks-for-specific-exceptions",
    "href": "part-05/lecture-errors-presentation.html#try-except-blocks-for-specific-exceptions",
    "title": "Lecture V - Handling Errors",
    "section": "try-except Blocks for specific exceptions",
    "text": "try-except Blocks for specific exceptions\n\nWe can also specify the type of exception we want to catch\nThis allows for more specific error handling\n\ntry:\n    # Code that might raise an exception\n    # ...\nexcept ExceptionType as e:\n    # Code to handle the specific exception type\n    # ...\nexcept:\n    # Code to handle any other exceptions\n    # ...\n\n\n\n\n\n\n\nNote\n\n\nas e is used to store the exception in a variable. Not mandatory, but good practice to do so."
  }
]